"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[7044],{43023:(e,t,n)=>{n.d(t,{R:()=>o,x:()=>r});var i=n(63696);const a={},s=i.createContext(a);function o(e){const t=i.useContext(s);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:o(e.components),i.createElement(s.Provider,{value:t},e.children)}},70458:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>r,default:()=>p,frontMatter:()=>o,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"intermediate/custom-entity-creation","title":"Custom Entity Creation","description":"On the server, entities are ECS objects with components. You define entity loaders that specify which components an entity type has, then spawn instances of those entities.","source":"@site/docs/tutorials/intermediate/3-custom-entity-creation.md","sourceDirName":"intermediate","slug":"/intermediate/custom-entity-creation","permalink":"/tutorials/intermediate/custom-entity-creation","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3},"sidebar":"tutorialSidebar","previous":{"title":"The Client Entity","permalink":"/tutorials/intermediate/the-client-entity"},"next":{"title":"Metadata Component","permalink":"/tutorials/intermediate/metadata-component"}}');var a=n(62540),s=n(43023);const o={sidebar_position:3},r="Custom Entity Creation",d={},l=[{value:"Defining an Entity Loader",id:"defining-an-entity-loader",level:2},{value:"Spawning Entities",id:"spawning-entities",level:2},{value:"Adding Physics",id:"adding-physics",level:2},{value:"Adding AI Behavior",id:"adding-ai-behavior",level:2},{value:"Custom Components",id:"custom-components",level:2},{value:"Spawning via Methods",id:"spawning-via-methods",level:2},{value:"Deleting Entities",id:"deleting-entities",level:2},{value:"Entity Persistence",id:"entity-persistence",level:2},{value:"Example: Drop Entity",id:"example-drop-entity",level:2}];function c(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",...(0,s.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.header,{children:(0,a.jsx)(t.h1,{id:"custom-entity-creation",children:"Custom Entity Creation"})}),"\n",(0,a.jsx)(t.p,{children:"On the server, entities are ECS objects with components. You define entity loaders that specify which components an entity type has, then spawn instances of those entities."}),"\n",(0,a.jsx)(t.h2,{id:"defining-an-entity-loader",children:"Defining an Entity Loader"}),"\n",(0,a.jsxs)(t.p,{children:["Use ",(0,a.jsx)(t.code,{children:"world.set_entity_loader()"})," to define how an entity type is created:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-rust",metastring:'title="Entity Loader Definition"',children:'use nanoid::nanoid;\n\nworld.set_entity_loader("mob", |world, metadata| {\n    let body = RigidBody::new(\n        &AABB::new()\n            .scale_x(0.6)\n            .scale_y(1.8)\n            .scale_z(0.6)\n            .build()\n    ).build();\n    let interactor = world.physics_mut().register(&body);\n\n    world\n        .create_entity(&nanoid!(), "mob")\n        .with(PositionComp::default())\n        .with(RigidBodyComp::new(&body))\n        .with(InteractorComp::new(&interactor))\n        .with(CollisionsComp::new())\n});\n'})}),"\n",(0,a.jsx)(t.p,{children:"The loader receives the world and any metadata passed during spawning."}),"\n",(0,a.jsx)(t.h2,{id:"spawning-entities",children:"Spawning Entities"}),"\n",(0,a.jsx)(t.p,{children:"Spawn entities using the loader you defined:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-rust",metastring:'title="Basic Spawning"',children:'world.spawn_entity_at("mob", &Vec3(10.0, 80.0, 10.0));\n'})}),"\n",(0,a.jsx)(t.p,{children:"Spawn with initial metadata:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-rust",metastring:'title="Spawning with Metadata"',children:'let mut metadata = MetadataComp::default();\nmetadata.set::<PositionComp>("position", &PositionComp::new(10.0, 80.0, 10.0));\nmetadata.set("name", &"Bob".to_string());\n\nworld.spawn_entity_with_metadata("mob", &Vec3(10.0, 80.0, 10.0), metadata);\n'})}),"\n",(0,a.jsx)(t.h2,{id:"adding-physics",children:"Adding Physics"}),"\n",(0,a.jsx)(t.p,{children:"For entities that interact with the voxel world:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-rust",metastring:'title="Physical Entity"',children:'world.set_entity_loader("ball", |world, _| {\n    let mut body = RigidBody::new(\n        &AABB::new()\n            .scale_x(0.5)\n            .scale_y(0.5)\n            .scale_z(0.5)\n            .build()\n    )\n    .build();\n\n    body.gravity_multiplier = 1.0;\n    body.air_drag = 0.1;\n\n    let interactor = world.physics_mut().register(&body);\n\n    world\n        .create_entity(&nanoid!(), "ball")\n        .with(PositionComp::default())\n        .with(RigidBodyComp::new(&body))\n        .with(InteractorComp::new(&interactor))\n        .with(CollisionsComp::new())\n});\n'})}),"\n",(0,a.jsx)(t.h2,{id:"adding-ai-behavior",children:"Adding AI Behavior"}),"\n",(0,a.jsx)(t.p,{children:"For entities that chase players or wander:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-rust",metastring:'title="AI Entity"',children:'use std::time::Duration;\n\nworld.set_entity_loader("zombie", |world, _| {\n    let body = RigidBody::new(\n        &AABB::new()\n            .scale_x(0.6)\n            .scale_y(1.8)\n            .scale_z(0.6)\n            .build()\n    ).build();\n    let interactor = world.physics_mut().register(&body);\n\n    world\n        .create_entity(&nanoid!(), "zombie")\n        .with(PositionComp::default())\n        .with(RigidBodyComp::new(&body))\n        .with(InteractorComp::new(&interactor))\n        .with(BrainComp::new(BrainOptions {\n            max_speed: 4.0,\n            jump_impulse: 8.0,\n            ..Default::default()\n        }))\n        .with(TargetComp::players())\n        .with(PathComp::new(\n            100,                       // max_nodes\n            24.0,                      // max_distance\n            10000,                     // max_depth_search\n            Duration::from_millis(50), // max_pathfinding_time\n        ))\n});\n'})}),"\n",(0,a.jsx)(t.p,{children:"The AI systems will automatically find targets and move toward them."}),"\n",(0,a.jsx)(t.h2,{id:"custom-components",children:"Custom Components"}),"\n",(0,a.jsx)(t.p,{children:"Define custom components for entity-specific data:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-rust",metastring:'title="Custom Component"',children:"use specs::{Component, VecStorage};\nuse serde::{Serialize, Deserialize};\n\n#[derive(Component, Default, Serialize, Deserialize)]\n#[storage(VecStorage)]\npub struct HealthComp(pub i32);\n\n#[derive(Component, Default)]\n#[storage(NullStorage<BossFlag>)]\npub struct BossFlag;\n"})}),"\n",(0,a.jsx)(t.p,{children:"Register components with the ECS:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-rust",metastring:'title="Registering Components"',children:"world.ecs_mut().register::<HealthComp>();\nworld.ecs_mut().register::<BossFlag>();\n"})}),"\n",(0,a.jsx)(t.p,{children:"Use them in entity loaders:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-rust",metastring:'title="Using Custom Components"',children:'world.set_entity_loader("boss", |world, metadata| {\n    let health = metadata.get::<HealthComp>("health").unwrap_or(HealthComp(100));\n\n    world\n        .create_entity(&nanoid!(), "boss")\n        .with(BossFlag)\n        .with(health)\n        .with(PositionComp::default())\n        // ... other components\n});\n'})}),"\n",(0,a.jsx)(t.h2,{id:"spawning-via-methods",children:"Spawning via Methods"}),"\n",(0,a.jsx)(t.p,{children:"Allow clients to spawn entities via methods:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-rust",metastring:'title="Spawn Method"',children:'#[derive(Serialize, Deserialize)]\nstruct SpawnMobPayload {\n    position: Vec3<f32>,\n    name: Option<String>,\n}\n\nworld.set_method_handle("spawn-mob", |world, _, payload| {\n    let data: SpawnMobPayload = serde_json::from_str(payload)\n        .expect("Invalid spawn-mob payload");\n\n    let mut metadata = MetadataComp::default();\n    if let Some(name) = data.name {\n        metadata.set("name", &name);\n    }\n\n    world.spawn_entity_with_metadata("mob", &data.position, metadata);\n});\n'})}),"\n",(0,a.jsx)(t.p,{children:"Call from the client:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-ts",metastring:'title="Client Spawn Call"',children:'method.call("spawn-mob", {\n  position: [10, 80, 10],\n  name: "Bob",\n});\n'})}),"\n",(0,a.jsx)(t.h2,{id:"deleting-entities",children:"Deleting Entities"}),"\n",(0,a.jsx)(t.p,{children:"Remove entities from the ECS:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-rust",metastring:'title="Deleting Entities"',children:'world.set_method_handle("kill-mob", |world, _, payload| {\n    let id: String = serde_json::from_str(payload).unwrap();\n\n    let entity_ids = world.entity_ids();\n    if let Some(&ent_id) = entity_ids.get(&id) {\n        drop(entity_ids);\n\n        let entities = world.ecs().entities();\n        if let Some(entity) = entities.entity(ent_id) {\n            entities.delete(entity).ok();\n        }\n    }\n});\n'})}),"\n",(0,a.jsx)(t.h2,{id:"entity-persistence",children:"Entity Persistence"}),"\n",(0,a.jsxs)(t.p,{children:["Entities with ",(0,a.jsx)(t.code,{children:"config.saving = true"})," are automatically saved to disk. They're stored in ",(0,a.jsx)(t.code,{children:"{save_dir}/entities/{entity_id}.json"}),"."]}),"\n",(0,a.jsx)(t.p,{children:"When the world loads, entities are revived using their loaders:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-rust",metastring:'title="Entity Revival"',children:"// Automatically called during world.prepare()\n// Entities are restored with their saved metadata\n"})}),"\n",(0,a.jsx)(t.h2,{id:"example-drop-entity",children:"Example: Drop Entity"}),"\n",(0,a.jsx)(t.p,{children:"A pickup item that players can collect:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-rust",metastring:'title="Drop Entity"',children:"#[derive(Component, Default, Serialize, Deserialize)]\n#[storage(VecStorage)]\npub struct DropComp {\n    pub item_id: u32,\n    pub count: u32,\n}\n\nworld.set_entity_loader(\"drop\", |world, metadata| {\n    let drop_data = metadata.get::<DropComp>(\"drop\").unwrap_or_default();\n\n    world\n        .create_entity(&nanoid!(), \"drop\")\n        .with(PositionComp::default())\n        .with(drop_data)\n});\n\n// Custom system to handle pickup\nstruct DropPickupSystem;\n\nimpl<'a> System<'a> for DropPickupSystem {\n    type SystemData = (\n        Entities<'a>,\n        ReadStorage<'a, DropComp>,\n        ReadStorage<'a, PositionComp>,\n        ReadStorage<'a, ClientFlag>,\n        WriteStorage<'a, InventoryComp>,\n    );\n\n    fn run(&mut self, data: Self::SystemData) {\n        // Check distance between drops and players\n        // Add to inventory and delete drop entity\n    }\n}\n"})}),"\n",(0,a.jsxs)(t.p,{children:["Read on to learn about the ",(0,a.jsx)(t.a,{href:"./metadata-component",children:"metadata component"})," for syncing entity data to clients."]})]})}function p(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(c,{...e})}):c(e)}}}]);