"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[6892],{35578:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>h,frontMatter:()=>a,metadata:()=>r,toc:()=>d});const r=JSON.parse('{"id":"blocks/custom-block-rendering","title":"Custom Block Rendering","description":"Block entities let you render custom visuals for individual blocks based on per-block data. The same block type can display completely different content at each location.","source":"@site/docs/wiki/blocks/custom-block-rendering.md","sourceDirName":"blocks","slug":"/blocks/custom-block-rendering","permalink":"/wiki/blocks/custom-block-rendering","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4},"sidebar":"tutorialSidebar","previous":{"title":"Chunk Meshing","permalink":"/wiki/blocks/chunk-meshing"},"next":{"title":"Networking","permalink":"/wiki/category/networking"}}');var i=t(62540),s=t(43023);const a={sidebar_position:4},l="Custom Block Rendering",o={},d=[{value:"The Pattern",id:"the-pattern",level:2},{value:"Example: Trophy Display Block",id:"example-trophy-display-block",level:2},{value:"Server: Register the Block Entity",id:"server-register-the-block-entity",level:3},{value:"Client: Listen for Block Entity Updates",id:"client-listen-for-block-entity-updates",level:3},{value:"Client: Initialize",id:"client-initialize",level:3},{value:"Example: Sign Block with Custom Text",id:"example-sign-block-with-custom-text",level:2},{value:"Example: Picture Frame with Uploaded Images",id:"example-picture-frame-with-uploaded-images",level:2},{value:"Key APIs",id:"key-apis",level:2},{value:"Tips",id:"tips",level:2},{value:"Related Pages",id:"related-pages",level:2}];function c(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"custom-block-rendering",children:"Custom Block Rendering"})}),"\n",(0,i.jsx)(n.p,{children:"Block entities let you render custom visuals for individual blocks based on per-block data. The same block type can display completely different content at each location."}),"\n",(0,i.jsx)(n.h2,{id:"the-pattern",children:"The Pattern"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Server"})," stores metadata for each block entity (text, image URL, model URL, colors, etc.)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Client"})," listens for block entity updates via ",(0,i.jsx)(n.code,{children:"world.addBlockEntityUpdateListener"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Client"})," renders custom visuals (textures, 3D models, canvas drawings) based on the metadata"]}),"\n"]}),"\n",(0,i.jsx)(n.mermaid,{value:'sequenceDiagram\n    participant Player\n    participant Server\n    participant Client\n\n    Player->>Server: Place "Trophy Block"\n    Server->>Server: Create block entity with metadata\n    Server->>Client: ENTITY CREATE {type: "trophy", rank: "gold"}\n    Client->>Client: Load gold trophy model, add to scene\n\n    Player->>Server: Place another "Trophy Block"\n    Server->>Server: Create block entity with different metadata\n    Server->>Client: ENTITY CREATE {type: "trophy", rank: "silver"}\n    Client->>Client: Load silver trophy model, add to scene'}),"\n",(0,i.jsx)(n.h2,{id:"example-trophy-display-block",children:"Example: Trophy Display Block"}),"\n",(0,i.jsx)(n.p,{children:'A single "Trophy" block type that displays different 3D models based on stored rank data.'}),"\n",(0,i.jsx)(n.h3,{id:"server-register-the-block-entity",children:"Server: Register the Block Entity"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",metastring:'title="Server Block Entity"',children:'use voxelize::*;\nuse serde::{Deserialize, Serialize};\n\n#[derive(Serialize, Deserialize, Clone)]\nstruct TrophyData {\n    rank: String,\n}\n\nlet trophy_block = Block::new("Trophy")\n    .id(100)\n    .is_entity(true)\n    .build();\n\nregistry.register_block(&trophy_block);\n\nworld.set_entity_loader("block::trophy", |world, metadata| {\n    let data: TrophyData = serde_json::from_value(metadata).unwrap_or(TrophyData {\n        rank: "bronze".to_string(),\n    });\n\n    world.create_entity(&nanoid!(), "block::trophy")\n        .with(MetadataComp::from_json(&serde_json::json!({\n            "type": "trophy",\n            "rank": data.rank,\n        })))\n});\n'})}),"\n",(0,i.jsx)(n.h3,{id:"client-listen-for-block-entity-updates",children:"Client: Listen for Block Entity Updates"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",metastring:'title="Client Block Entity Handler"',children:'import * as VOXELIZE from "@voxelize/core";\nimport * as THREE from "three";\nimport { GLTFLoader } from "three/examples/jsm/loaders/GLTFLoader.js";\n\ntype TrophyMetadata = {\n  type: "trophy";\n  rank: "gold" | "silver" | "bronze";\n};\n\nconst TROPHY_MODELS: Record<string, string> = {\n  gold: "/models/trophy-gold.gltf",\n  silver: "/models/trophy-silver.gltf",\n  bronze: "/models/trophy-bronze.gltf",\n};\n\nclass TrophyRenderer {\n  private trophies = new Map<string, THREE.Group>();\n  private loader = new GLTFLoader();\n\n  constructor(private world: VOXELIZE.World) {\n    world.addBlockEntityUpdateListener(this.handleUpdate);\n  }\n\n  handleUpdate = (args: VOXELIZE.BlockEntityUpdateData<TrophyMetadata>) => {\n    const { id, operation, newValue, voxel } = args;\n\n    if (newValue?.type !== "trophy") return;\n\n    if (operation === "CREATE" || operation === "UPDATE") {\n      this.loadTrophy(id, voxel, newValue.rank);\n    } else if (operation === "DELETE") {\n      this.removeTrophy(id);\n    }\n  };\n\n  private async loadTrophy(id: string, voxel: number[], rank: string) {\n    this.removeTrophy(id);\n\n    const modelUrl = TROPHY_MODELS[rank] || TROPHY_MODELS.bronze;\n\n    const gltf = await this.loader.loadAsync(modelUrl);\n    const model = gltf.scene;\n\n    model.scale.set(0.4, 0.4, 0.4);\n    model.position.set(voxel[0] + 0.5, voxel[1] + 0.5, voxel[2] + 0.5);\n\n    this.trophies.set(id, model);\n    this.world.add(model);\n  }\n\n  private removeTrophy(id: string) {\n    const existing = this.trophies.get(id);\n    if (existing) {\n      this.world.remove(existing);\n      this.trophies.delete(id);\n    }\n  }\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"client-initialize",children:"Client: Initialize"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",metastring:'title="Setup"',children:"const world = new VOXELIZE.World();\nconst trophyRenderer = new TrophyRenderer(world);\n"})}),"\n",(0,i.jsx)(n.h2,{id:"example-sign-block-with-custom-text",children:"Example: Sign Block with Custom Text"}),"\n",(0,i.jsx)(n.p,{children:"A sign block that renders text onto a canvas texture, applied per-block."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",metastring:'title="Sign Renderer"',children:'type SignMetadata = {\n  type: "sign";\n  text: string;\n  color?: string;\n};\n\nclass SignRenderer {\n  private textures = new Map<string, THREE.CanvasTexture>();\n\n  constructor(private world: VOXELIZE.World) {\n    world.addBlockEntityUpdateListener(this.handleUpdate);\n  }\n\n  handleUpdate = (args: VOXELIZE.BlockEntityUpdateData<SignMetadata>) => {\n    const { id, operation, newValue, voxel } = args;\n\n    if (newValue?.type !== "sign") return;\n\n    if (operation === "CREATE" || operation === "UPDATE") {\n      this.renderSign(id, voxel, newValue);\n    } else if (operation === "DELETE") {\n      this.disposeTexture(id);\n    }\n  };\n\n  private renderSign(id: string, voxel: number[], data: SignMetadata) {\n    this.disposeTexture(id);\n\n    const canvas = document.createElement("canvas");\n    canvas.width = 256;\n    canvas.height = 128;\n\n    const ctx = canvas.getContext("2d")!;\n    ctx.fillStyle = "#8B4513";\n    ctx.fillRect(0, 0, 256, 128);\n\n    ctx.fillStyle = data.color || "#FFFFFF";\n    ctx.font = "24px monospace";\n    ctx.textAlign = "center";\n    ctx.textBaseline = "middle";\n\n    const lines = data.text.split("\\\\n");\n    const lineHeight = 28;\n    const startY = 64 - ((lines.length - 1) * lineHeight) / 2;\n\n    lines.forEach((line, i) => {\n      ctx.fillText(line, 128, startY + i * lineHeight);\n    });\n\n    const texture = new THREE.CanvasTexture(canvas);\n    texture.magFilter = THREE.NearestFilter;\n    texture.minFilter = THREE.NearestFilter;\n    texture.needsUpdate = true;\n\n    this.textures.set(id, texture);\n\n    this.world.applyBlockTextureAt(\n      "Sign",\n      "pz",\n      texture,\n      voxel as [number, number, number]\n    );\n  }\n\n  private disposeTexture(id: string) {\n    const texture = this.textures.get(id);\n    if (texture) {\n      texture.dispose();\n      this.textures.delete(id);\n    }\n  }\n}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"example-picture-frame-with-uploaded-images",children:"Example: Picture Frame with Uploaded Images"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",metastring:'title="Picture Frame Renderer"',children:'type PictureFrameMetadata = {\n  type: "picture-frame";\n  imageSource: string;\n  objectFit?: "cover" | "contain";\n};\n\nclass PictureFrameRenderer {\n  private textures = new Map<string, THREE.CanvasTexture>();\n\n  constructor(private world: VOXELIZE.World) {\n    world.addBlockEntityUpdateListener(this.handleUpdate);\n  }\n\n  handleUpdate = (\n    args: VOXELIZE.BlockEntityUpdateData<PictureFrameMetadata>\n  ) => {\n    const { id, operation, newValue, voxel } = args;\n\n    if (newValue?.type !== "picture-frame") return;\n\n    if (operation === "CREATE" || operation === "UPDATE") {\n      this.renderFrame(id, voxel, newValue);\n    } else if (operation === "DELETE") {\n      this.disposeTexture(id);\n    }\n  };\n\n  private async renderFrame(\n    id: string,\n    voxel: number[],\n    data: PictureFrameMetadata\n  ) {\n    if (!data.imageSource) return;\n\n    this.disposeTexture(id);\n\n    const image = await this.world.loader.loadImage(data.imageSource);\n\n    const canvas = document.createElement("canvas");\n    canvas.width = 256;\n    canvas.height = 256;\n\n    const ctx = canvas.getContext("2d")!;\n\n    if (data.objectFit === "contain") {\n      const scale = Math.min(256 / image.width, 256 / image.height);\n      const w = image.width * scale;\n      const h = image.height * scale;\n      ctx.drawImage(image, (256 - w) / 2, (256 - h) / 2, w, h);\n    } else {\n      const scale = Math.max(256 / image.width, 256 / image.height);\n      const w = image.width * scale;\n      const h = image.height * scale;\n      ctx.drawImage(image, (256 - w) / 2, (256 - h) / 2, w, h);\n    }\n\n    const texture = new THREE.CanvasTexture(canvas);\n    texture.magFilter = THREE.NearestFilter;\n    texture.needsUpdate = true;\n\n    this.textures.set(id, texture);\n\n    this.world.applyBlockTextureAt(\n      "Picture Frame",\n      "pz",\n      texture,\n      voxel as [number, number, number]\n    );\n  }\n\n  private disposeTexture(id: string) {\n    const texture = this.textures.get(id);\n    if (texture) {\n      texture.dispose();\n      this.textures.delete(id);\n    }\n  }\n}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"key-apis",children:"Key APIs"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Method"}),(0,i.jsx)(n.th,{children:"Purpose"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"world.addBlockEntityUpdateListener(callback)"})}),(0,i.jsx)(n.td,{children:"Listen for block entity changes"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"world.getBlockEntityDataAt(x, y, z)"})}),(0,i.jsx)(n.td,{children:"Read metadata at a voxel"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"world.setBlockEntityDataAt(x, y, z, data)"})}),(0,i.jsx)(n.td,{children:"Write metadata at a voxel"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"world.applyBlockTextureAt(blockName, face, texture, voxel)"})}),(0,i.jsx)(n.td,{children:"Apply a texture to a specific block instance"})]})]})]}),"\n",(0,i.jsx)(n.h2,{id:"tips",children:"Tips"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Dispose resources"})," - Always clean up textures and models when blocks are deleted to prevent memory leaks"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Queue loading"})," - For many blocks loading models/images, use a queue to avoid overwhelming the browser"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Cache textures"})," - Reuse textures for identical content when possible"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsxs)(n.strong,{children:["Use ",(0,i.jsx)(n.code,{children:"NearestFilter"})]})," - For pixel-art style textures, prevents blurry scaling"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["See the town project's ",(0,i.jsx)(n.code,{children:"client/src/core/block-entities.ts"})," for a production implementation handling signs, picture frames, screens, and 3D model spawners."]}),"\n",(0,i.jsx)(n.h2,{id:"related-pages",children:"Related Pages"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"/wiki/blocks/block-registry",children:"Block Registry"})," - Server-side block configuration"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"/wiki/blocks/block-textures",children:"Block Textures"})," - Client-side texture application"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"/wiki/blocks/chunk-meshing",children:"Chunk Meshing"})," - How blocks become geometry"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},43023:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>l});var r=t(63696);const i={},s=r.createContext(i);function a(e){const n=r.useContext(s);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),r.createElement(s.Provider,{value:n},e.children)}}}]);