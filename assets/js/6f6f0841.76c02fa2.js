"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[1826],{91276:e=>{e.exports=JSON.parse('{"version":{"pluginId":"tutorials","version":"current","label":"Next","banner":null,"badge":false,"noIndex":false,"className":"docs-version-current","isLast":true,"docsSidebars":{"tutorialSidebar":[{"type":"category","label":"Introduction","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"What is Voxelize?","href":"/tutorials/intro/what-is-voxelize","docId":"intro/what-is-voxelize","unlisted":false},{"type":"link","label":"Getting Started","href":"/tutorials/intro/getting-started","docId":"intro/getting-started","unlisted":false},{"type":"link","label":"Installation","href":"/tutorials/intro/installation","docId":"intro/installation","unlisted":false}]},{"type":"category","label":"The Basics","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Create the Server","href":"/tutorials/basics/create-the-server","docId":"basics/create-the-server","unlisted":false},{"type":"link","label":"Register Blocks","href":"/tutorials/basics/register-blocks","docId":"basics/register-blocks","unlisted":false},{"type":"link","label":"Create a World","href":"/tutorials/basics/create-a-world","docId":"basics/create-a-world","unlisted":false},{"type":"link","label":"World Configuration","href":"/tutorials/basics/world-configuration","docId":"basics/world-configuration","unlisted":false},{"type":"link","label":"Chunk Generation","href":"/tutorials/basics/chunk-generation","docId":"basics/chunk-generation","unlisted":false},{"type":"link","label":"Create the Client","href":"/tutorials/basics/create-the-client","docId":"basics/create-the-client","unlisted":false},{"type":"link","label":"Handle the Network","href":"/tutorials/basics/handle-the-network","docId":"basics/handle-the-network","unlisted":false},{"type":"link","label":"Initialize the World","href":"/tutorials/basics/initialize-the-world","docId":"basics/initialize-the-world","unlisted":false},{"type":"link","label":"Apply Textures","href":"/tutorials/basics/texturing-blocks","docId":"basics/texturing-blocks","unlisted":false},{"type":"link","label":"Player Control","href":"/tutorials/basics/player-control","docId":"basics/player-control","unlisted":false},{"type":"link","label":"Debug Voxelize","href":"/tutorials/basics/debug-ui","docId":"basics/debug-ui","unlisted":false},{"type":"link","label":"Update Voxels","href":"/tutorials/basics/update-voxels","docId":"basics/update-voxels","unlisted":false},{"type":"link","label":"Set Perspectives","href":"/tutorials/basics/perspectives-and-visuals","docId":"basics/perspectives-and-visuals","unlisted":false},{"type":"link","label":"Multiplayer","href":"/tutorials/basics/multiplayer","docId":"basics/multiplayer","unlisted":false}],"href":"/tutorials/category/the-basics"},{"type":"category","label":"Intermediate","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Entity Component System","href":"/tutorials/intermediate/entity-component-system","docId":"intermediate/entity-component-system","unlisted":false},{"type":"link","label":"The Client Entity","href":"/tutorials/intermediate/the-client-entity","docId":"intermediate/the-client-entity","unlisted":false},{"type":"link","label":"Custom Entity Creation","href":"/tutorials/intermediate/custom-entity-creation","docId":"intermediate/custom-entity-creation","unlisted":false},{"type":"link","label":"Metadata Component","href":"/tutorials/intermediate/metadata-component","docId":"intermediate/metadata-component","unlisted":false},{"type":"link","label":"Customizing the ECS","href":"/tutorials/intermediate/customizing-the-ecs","docId":"intermediate/customizing-the-ecs","unlisted":false},{"type":"link","label":"Network Interception","href":"/tutorials/intermediate/network-interception","docId":"intermediate/network-interception","unlisted":false},{"type":"link","label":"Collision Detection","href":"/tutorials/intermediate/collision-detection","docId":"intermediate/collision-detection","unlisted":false},{"type":"link","label":"The Events System","href":"/tutorials/intermediate/the-events-system","docId":"intermediate/the-events-system","unlisted":false},{"type":"link","label":"Method Handling","href":"/tutorials/intermediate/method-handling","docId":"intermediate/method-handling","unlisted":false},{"type":"link","label":"Chat and Colored Text","href":"/tutorials/intermediate/chat-and-colored-text","docId":"intermediate/chat-and-colored-text","unlisted":false},{"type":"link","label":"Protocol Networking","href":"/tutorials/intermediate/protocol-networking","docId":"intermediate/protocol-networking","unlisted":false},{"type":"link","label":"Custom Blocks","href":"/tutorials/intermediate/custom-blocks","docId":"intermediate/custom-blocks","unlisted":false},{"type":"link","label":"TypeScript Transport","href":"/tutorials/intermediate/typescript-transport","docId":"intermediate/typescript-transport","unlisted":false}],"href":"/tutorials/category/intermediate"}]},"docs":{"basics/chunk-generation":{"id":"basics/chunk-generation","title":"Chunk Generation","description":"Populate empty chunks with terrain using chunk stages. Each chunk goes through all stages in sequence.","sidebar":"tutorialSidebar"},"basics/create-a-world":{"id":"basics/create-a-world","title":"Create a World","description":"A server can have multiple worlds. This tutorial creates one world called \\"tutorial\\".","sidebar":"tutorialSidebar"},"basics/create-the-client":{"id":"basics/create-the-client","title":"Create the Client","description":"The client connects to the server, joins a world, and renders it with ThreeJS.","sidebar":"tutorialSidebar"},"basics/create-the-server":{"id":"basics/create-the-server","title":"Create the Server","description":"The Voxelize server handles terrain generation, meshing, and physics in parallel threads. This keeps the client fast.","sidebar":"tutorialSidebar"},"basics/debug-ui":{"id":"basics/debug-ui","title":"Debug Voxelize","description":"It is fairly easy to use the built-in voxelize debug UI. All you have to do is:","sidebar":"tutorialSidebar"},"basics/handle-the-network":{"id":"basics/handle-the-network","title":"Handle the Network","description":"The network manager connects to the server over WebSockets and handles all game data.","sidebar":"tutorialSidebar"},"basics/initialize-the-world":{"id":"basics/initialize-the-world","title":"Initialize the World","description":"Upon connecting to the server, the voxelize world receives a INIT packet since it\'s registered onto the network. We need to use that packet and initialize the world so that world.isInitialized would be true.","sidebar":"tutorialSidebar"},"basics/multiplayer":{"id":"basics/multiplayer","title":"Multiplayer","description":"Voxelize uses WebSockets for real-time multiplayer. The Peers class manages other players\' positions and renders their characters.","sidebar":"tutorialSidebar"},"basics/perspectives-and-visuals":{"id":"basics/perspectives-and-visuals","title":"Set Perspectives","description":"Me personally, I really like to play games in 3rd person\'s perspective. So, let\'s quickly add perspective switching to our app by pressing \\"c\\".","sidebar":"tutorialSidebar"},"basics/player-control":{"id":"basics/player-control","title":"Player Control","description":"Voxelize provides RigidControls, a physics-based controller for walking, running, jumping, and flying around voxel worlds. It wraps ThreeJS\'s PointerLockControls and adds collision detection.","sidebar":"tutorialSidebar"},"basics/register-blocks":{"id":"basics/register-blocks","title":"Register Blocks","description":"A voxel world has millions of blocks. Each block type needs properties - is it solid? transparent? what shape?","sidebar":"tutorialSidebar"},"basics/texturing-blocks":{"id":"basics/texturing-blocks","title":"Apply Textures","description":"The next step that we will be taking is to apply textures to the blocks. Right now, the block textures are all question marks since we haven\'t applied any textures yet. We will be using the following four textures under public/blocks. The reason why grass_side.png is blurry is because it\'s actually only 8 pixels in dimension.","sidebar":"tutorialSidebar"},"basics/update-voxels":{"id":"basics/update-voxels","title":"Update Voxels","description":"To modify voxels, we need to know which block the player is looking at. Voxelize uses a fast ray-voxel intersection algorithm based on this paper.","sidebar":"tutorialSidebar"},"basics/world-configuration":{"id":"basics/world-configuration","title":"World Configuration","description":"Configure world boundaries, time cycles, physics, and performance settings.","sidebar":"tutorialSidebar"},"intermediate/chat-and-colored-text":{"id":"intermediate/chat-and-colored-text","title":"Chat and Colored Text","description":"Voxelize provides a chat system for player communication and a colored text utility for styled text rendering.","sidebar":"tutorialSidebar"},"intermediate/collision-detection":{"id":"intermediate/collision-detection","title":"Collision Detection","description":"Voxelize uses Rapier physics for entity-to-entity collision detection. Entities with InteractorComp can detect when they collide with other interactors.","sidebar":"tutorialSidebar"},"intermediate/custom-blocks":{"id":"intermediate/custom-blocks","title":"Custom Blocks","description":"Beyond basic blocks, Voxelize supports advanced block configurations including rotations, transparency, custom shapes, and dynamic behaviors.","sidebar":"tutorialSidebar"},"intermediate/custom-entity-creation":{"id":"intermediate/custom-entity-creation","title":"Custom Entity Creation","description":"On the server, entities are ECS objects with components. You define entity loaders that specify which components an entity type has, then spawn instances of those entities.","sidebar":"tutorialSidebar"},"intermediate/customizing-the-ecs":{"id":"intermediate/customizing-the-ecs","title":"Customizing the ECS","description":"Voxelize\'s server runs on Specs ECS, which executes systems in parallel each game tick. You can customize the dispatcher to add your own systems, modify execution order, or extend built-in behaviors.","sidebar":"tutorialSidebar"},"intermediate/entity-component-system":{"id":"intermediate/entity-component-system","title":"Entity Component System","description":"Voxelize servers run on the Specs ECS crate. It is recommended to read through the Specs ECS tutorial before continuing.","sidebar":"tutorialSidebar"},"intermediate/metadata-component":{"id":"intermediate/metadata-component","title":"Metadata Component","description":"Metadata is how entity state gets synchronized from server to client. The MetadataComp stores a JSON-serializable map that gets sent to clients whenever it changes.","sidebar":"tutorialSidebar"},"intermediate/method-handling":{"id":"intermediate/method-handling","title":"Method Handling","description":"Methods are world-wide RPC calls from client to server. They\'re used for actions that affect game state, like spawning entities, updating inventories, or changing world settings.","sidebar":"tutorialSidebar"},"intermediate/network-interception":{"id":"intermediate/network-interception","title":"Network Interception","description":"Network interceptors allow you to hook into the message flow between client and server. Any object with an onMessage method can be registered as an interceptor.","sidebar":"tutorialSidebar"},"intermediate/protocol-networking":{"id":"intermediate/protocol-networking","title":"Protocol Networking","description":"Voxelize uses Protocol Buffers for efficient binary serialization of network messages. Understanding the protocol helps when building custom features.","sidebar":"tutorialSidebar"},"intermediate/the-client-entity":{"id":"intermediate/the-client-entity","title":"The Client Entity","description":"On the client side, entities are Three.js objects that represent server-side ECS entities. They receive data updates from the server and render accordingly.","sidebar":"tutorialSidebar"},"intermediate/the-events-system":{"id":"intermediate/the-events-system","title":"The Events System","description":"Events are location-based messages that broadcast to nearby clients. Unlike methods which are world-wide RPC calls, events only reach clients who have the originating chunk loaded.","sidebar":"tutorialSidebar"},"intermediate/typescript-transport":{"id":"intermediate/typescript-transport","title":"TypeScript Transport","description":"The Transport class is a server-side WebSocket client that connects to the Voxelize game server from an external Node.js process. It receives the same real-time events that browser clients receive (player joins, chat messages, entity updates), enabling you to build services that react to game activity.","sidebar":"tutorialSidebar"},"intro/getting-started":{"id":"intro/getting-started","title":"Getting Started","description":"This tutorial builds a multiplayer voxel world from scratch. You\'ll follow along with the voxelize-tutorial repository.","sidebar":"tutorialSidebar"},"intro/installation":{"id":"intro/installation","title":"Installation","description":"The tutorial repo is already set up with dependencies. Here\'s what\'s included:","sidebar":"tutorialSidebar"},"intro/what-is-voxelize":{"id":"intro/what-is-voxelize","title":"What is Voxelize?","description":"Voxelize is a fullstack library for building fast, multiplayer voxel experiences in the browser.","sidebar":"tutorialSidebar"}}}}')}}]);