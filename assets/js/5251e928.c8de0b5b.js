"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[2848],{26883:e=>{e.exports=JSON.parse('{"version":{"pluginId":"wiki","version":"current","label":"Next","banner":null,"badge":false,"noIndex":false,"className":"docs-version-current","isLast":true,"docsSidebars":{"tutorialSidebar":[{"type":"category","label":"Blocks","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Block Registry","href":"/wiki/blocks/block-registry","docId":"blocks/block-registry","unlisted":false},{"type":"link","label":"Block Textures","href":"/wiki/blocks/block-textures","docId":"blocks/block-textures","unlisted":false},{"type":"link","label":"Chunk Meshing","href":"/wiki/blocks/chunk-meshing","docId":"blocks/chunk-meshing","unlisted":false},{"type":"link","label":"Custom Block Rendering","href":"/wiki/blocks/custom-block-rendering","docId":"blocks/custom-block-rendering","unlisted":false}],"href":"/wiki/category/blocks"},{"type":"category","label":"Networking","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Calling Methods","href":"/wiki/networking/calling-methods","docId":"networking/calling-methods","unlisted":false},{"type":"link","label":"Handling Events","href":"/wiki/networking/handling-events","docId":"networking/handling-events","unlisted":false},{"type":"link","label":"Metadata Processing","href":"/wiki/networking/metadata-processing","docId":"networking/metadata-processing","unlisted":false},{"type":"link","label":"Custom Dispatcher","href":"/wiki/networking/custom-dispatcher","docId":"networking/custom-dispatcher","unlisted":false},{"type":"link","label":"Transport","href":"/wiki/networking/transport","docId":"networking/transport","unlisted":false}],"href":"/wiki/category/networking"},{"type":"category","label":"Entities","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Custom Entities","href":"/wiki/entities/custom-entities","docId":"entities/custom-entities","unlisted":false},{"type":"link","label":"Custom Peers","href":"/wiki/entities/custom-peers","docId":"entities/custom-peers","unlisted":false}],"href":"/wiki/category/entities"}]},"docs":{"blocks/block-registry":{"id":"blocks/block-registry","title":"Block Registry","description":"The block registry defines all block types on the server\u2014their physical properties, face geometry, transparency, and special behaviors like block entities and dynamic connections.","sidebar":"tutorialSidebar"},"blocks/block-textures":{"id":"blocks/block-textures","title":"Block Textures","description":"Apply textures to blocks on the client using images, colors, canvas, or animated sources. Blocks must be registered on the server first\u2014see Block Registry for server-side configuration.","sidebar":"tutorialSidebar"},"blocks/chunk-meshing":{"id":"blocks/chunk-meshing","title":"Chunk Meshing","description":"Chunk meshing transforms raw voxel data into renderable 3D geometry. Understanding how meshes are built helps you customize the visual appearance of your world.","sidebar":"tutorialSidebar"},"blocks/custom-block-rendering":{"id":"blocks/custom-block-rendering","title":"Custom Block Rendering","description":"Block entities let you render custom visuals for individual blocks based on per-block data. The same block type can display completely different content at each location.","sidebar":"tutorialSidebar"},"entities/custom-entities":{"id":"entities/custom-entities","title":"Custom Entities","description":"Entities are server-controlled objects that sync to clients - mobs, NPCs, projectiles, or any game object that needs authoritative state.","sidebar":"tutorialSidebar"},"entities/custom-peers":{"id":"entities/custom-peers","title":"Custom Peers","description":"Peers represent other players in the world. You can customize peer rendering by extending the Peers class and using mixins.","sidebar":"tutorialSidebar"},"networking/calling-methods":{"id":"networking/calling-methods","title":"Calling Methods","description":"Methods are RPC calls from client to server. Use them when a client action needs to trigger server-side logic - spawning entities, changing world state, or validating game rules.","sidebar":"tutorialSidebar"},"networking/custom-dispatcher":{"id":"networking/custom-dispatcher","title":"Custom Dispatcher","description":"The Voxelize server is built on top of the specs ECS framework. This means that the server is made up of a series of systems that are running in parallel. By default, Voxelize has a list of systems that are used to handle things like chunk generation, network packet handling, and more. These systems come together and define what happens every game tick.","sidebar":"tutorialSidebar"},"networking/handling-events":{"id":"networking/handling-events","title":"Handling Events","description":"Events broadcast messages to nearby clients. They\'re location-based - only players with the relevant chunk loaded receive the event. Use them for effects, notifications, and reactive game logic.","sidebar":"tutorialSidebar"},"networking/metadata-processing":{"id":"networking/metadata-processing","title":"Metadata Processing","description":"In Voxelize, metadata is a way to keep entities and players in sync with the server. Essentially, metadata is a JSON serializable object that contains the individual components that the entity itself possesses. For example, a player entity might have a position component, a rotation component, and a health component. These components are stored in the metadata object, and whenever these individual components are changed, the metadata object is updated and sent to the client.","sidebar":"tutorialSidebar"},"networking/transport":{"id":"networking/transport","title":"Transport","description":"Transport is a server-side WebSocket client that connects to Voxelize from external Node.js processes. It receives the same real-time events that browser clients receive, enabling backend services to react to game activity.","sidebar":"tutorialSidebar"}}}}')}}]);