"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[3286],{3023:(e,n,t)=>{t.d(n,{R:()=>l,x:()=>r});var s=t(3696);const i={},a=s.createContext(i);function l(e){const n=s.useContext(a);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:l(e.components),s.createElement(a.Provider,{value:n},e.children)}},5785:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>r,default:()=>h,frontMatter:()=>l,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"basics/chunk-generation","title":"Chunk Generation","description":"In this chapter, we learn about how to populate blocks into empty chunks, in parallel.","source":"@site/docs/tutorials/basics/5-chunk-generation.md","sourceDirName":"basics","slug":"/basics/chunk-generation","permalink":"/tutorials/basics/chunk-generation","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"sidebar_position":5},"sidebar":"tutorialSidebar","previous":{"title":"Create a World","permalink":"/tutorials/basics/create-a-world"},"next":{"title":"Create the Client","permalink":"/tutorials/basics/create-the-client"}}');var i=t(2540),a=t(3023);const l={sidebar_position:5},r="Chunk Generation",o={},c=[{value:"Chunk Stage",id:"chunk-stage",level:2},{value:"The Chunk Pipeline",id:"the-chunk-pipeline",level:2},{value:"A Word on Chunk Stages",id:"a-word-on-chunk-stages",level:2},{value:"Resources of the World",id:"resources-of-the-world",level:3},{value:"<code>Space</code>\xa0Data Structure",id:"spacedata-structure",level:3},{value:"Progress Check",id:"progress-check",level:2}];function d(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",img:"img",li:"li",p:"p",pre:"pre",ul:"ul",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"chunk-generation",children:"Chunk Generation"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{src:t(9335).A+"",width:"3456",height:"2158"})}),"\n",(0,i.jsx)(n.p,{children:"In this chapter, we learn about how to populate blocks into empty chunks, in parallel."}),"\n",(0,i.jsx)(n.h2,{id:"chunk-stage",children:"Chunk Stage"}),"\n",(0,i.jsxs)(n.p,{children:["To populate chunks, developers define a list of chunk stages that each chunk has to go through. For example, there could be a\xa0",(0,i.jsx)(n.code,{children:"TreeStage"}),"\xa0that places trees on each chunk, or there could be a\xa0",(0,i.jsx)(n.code,{children:"WaterStage"}),"\xa0that fills water up to the sea level."]}),"\n",(0,i.jsxs)(n.p,{children:["In this tutorial, we are going to define a\xa0",(0,i.jsx)(n.code,{children:"FlatlandStage"}),", which simply populates the world with a flat land. (",(0,i.jsx)(n.em,{children:"Hint: This stage actually comes built-in in Voxelize!"}),")"]}),"\n",(0,i.jsx)(n.p,{children:"Let's set up the flatland stage first:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",metastring:'title="server/main.rs"',children:"// ...\npub struct FlatlandStage {\n    /// The height of the flat land.\n    height: i32,\n\n    /// Block type of the top of the flat land.\n    top: u32,\n\n    /// Block type of the middle of the flat land.\n    middle: u32,\n\n    /// Block type of the bottom of the flat land.\n    bottom: u32,\n}\n\nimpl FlatlandStage {\n    pub fn new(height: i32, top: u32, middle: u32, bottom: u32) -> Self {\n        Self {\n            height,\n            top,\n            middle,\n            bottom,\n        }\n    }\n}\n// ...\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Chunk stages all implement the\xa0",(0,i.jsx)(n.code,{children:"ChunkStage"}),"\xa0trait, so let's do that next:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",metastring:'title="server/main.rs"',children:"use voxelize::{\n    Block, ChunkStage, Registry, ResourceResults, Server, Space, VoxelAccess, Voxelize, WorldConfig,\n};\n"})}),"\n",(0,i.jsx)(n.admonition,{type:"note",children:(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["The ",(0,i.jsx)(n.code,{children:"VoxelAccess"}),"\xa0trait allows developers to use chunk data access methods such as\xa0",(0,i.jsx)(n.code,{children:"set_voxel"})," on data structures like ",(0,i.jsx)(n.code,{children:"Chunk"})," or ",(0,i.jsx)(n.code,{children:"Chunks"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"Vec3"}),"\xa0is a 3-number list data structure used across Voxelize."]}),"\n"]})}),"\n",(0,i.jsx)(n.p,{children:"Implement what the flat land stage does:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",metastring:'title="server/main.rs"',children:'// ...\nimpl ChunkStage for FlatlandStage {\n    fn name(&self) -> String {\n        "Flatland".to_owned()\n    }\n\n    fn process(&self, mut chunk: Chunk, _: ResourceResults, _: Option<Space>) -> Chunk {\n        // Minimum coordinates of the chunk.\n        let Vec3(min_x, _, min_z) = chunk.min;\n\n        // Maximum coordinates of the chunk.\n        let Vec3(max_x, _, max_z) = chunk.max;\n\n        // Loop through all voxels up to the defined height.\n        for vx in min_x..max_x {\n            for vz in min_z..max_z {\n                for vy in 0..self.height {\n                    // Set voxels conditionally.\n                    if vy == 0 {\n                        chunk.set_voxel(vx, vy, vz, self.bottom);\n                    } else if vy == self.height - 1 {\n                        chunk.set_voxel(vx, vy, vz, self.top);\n                    } else {\n                        chunk.set_voxel(vx, vy, vz, self.middle);\n                    }\n                }\n            }\n        }\n\n        // Return the chunk instance for it to progress to the next stage.\n        chunk\n    }\n}\n// ...\n'})}),"\n",(0,i.jsx)(n.h2,{id:"the-chunk-pipeline",children:"The Chunk Pipeline"}),"\n",(0,i.jsx)(n.p,{children:"Now we have a chunk stage defined, it's time to add it to the world's pipeline. A chunk pipeline simply manages the multi-threading of the chunk populations, pipelining all the chunks requested through every stage."}),"\n",(0,i.jsx)(n.p,{children:"We can access the world pipeline and add the stage to it:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",metastring:'title="server/main.rs"',children:"// ... Creating the world\n\n{\n    drop(registry);\n\n    let mut pipeline = world.pipeline_mut();\n\n    // Add a chunk stage with top block stone, middle dirt, and bottom stone.\n    pipeline.add_stage(FlatlandStage::new(10, stone.id, dirt.id, stone.id));\n}\n\n// ... Running the server\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The world should now be generating a flat land. In fact, you can simply import\xa0",(0,i.jsx)(n.code,{children:"FlatlandStage"}),"\xa0from\xa0",(0,i.jsx)(n.code,{children:"voxelize::pipeline::FlatlandStage"}),". The usage is a bit different, as Voxelize's built-in flatland stage uses ",(0,i.jsx)(n.code,{children:"add_soiling"})," instead of ",(0,i.jsx)(n.code,{children:"top"}),", ",(0,i.jsx)(n.code,{children:"middle"}),", and ",(0,i.jsx)(n.code,{children:"bottom"})," blocks. An example usage would be as such:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",metastring:'title="server/main.rs"',children:"{\n    let mut pipeline = world.pipeline_mut();\n    pipeline.add_stage(\n        FlatlandStage::new()\n            .add_soiling(stone.id, 10) // From bottom-up, add 10 layers of stone\n            .add_soiling(dirt.id, 2) // 2 layers of dirt\n            .add_soiling(grass_block.id, 1), // Final 1 layer of grass block\n    )\n}\n"})}),"\n",(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsx)(n.p,{children:"We wrap the pipeline access with curly braces so that the pipeline lifetime is automatically dropped after mutating."})}),"\n",(0,i.jsx)(n.h2,{id:"a-word-on-chunk-stages",children:"A Word on Chunk Stages"}),"\n",(0,i.jsx)(n.p,{children:"When working with chunk stages, developers may want to access more information about the world, such as the registry, chunks around that chunk, and the world configurations."}),"\n",(0,i.jsx)(n.h3,{id:"resources-of-the-world",children:"Resources of the World"}),"\n",(0,i.jsxs)(n.p,{children:["Each chunk stage is presented with a set of resources from the world, namely the registry and the world config. You can access these resources within the second parameter for process, ",(0,i.jsx)(n.code,{children:"resources"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"// highlight-next-line\nuse voxelize::Resources;\n\nimpl ChunkStage for MyStage {\n    fn process(&self, chunk: Chunk, resources: Resources, space: Option<Space>) -> Chunk {\n        // Use the resource in this chunk stage.\n        // highlight-next-line\n        let registry = resources.registry;\n    }\n}\n"})}),"\n",(0,i.jsxs)(n.h3,{id:"spacedata-structure",children:[(0,i.jsx)(n.a,{href:"https://github.com/shaoruu/voxelize/blob/main/server/world/voxels/space.rs",children:(0,i.jsx)(n.code,{children:"Space"})}),"\xa0Data Structure"]}),"\n",(0,i.jsxs)(n.p,{children:["Voxelize achieves parallel chunk generation by utilizing a data structure called ",(0,i.jsx)(n.code,{children:"Space"}),". Essentially, spaces contain the data of a chunk along with the data of the surrounding chunks. Data includes voxels, lights, and height maps, all configurable."]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["A space is provided to the stage if the\xa0",(0,i.jsx)(n.code,{children:"stage.needs_space"}),"\xa0function is implemented."]}),"\n",(0,i.jsx)(n.li,{children:"Spaces ensures that it contains chunks in stages equal to or greater than the center chunk."}),"\n",(0,i.jsxs)(n.li,{children:["Spaces can also be mutated, but they are deleted after each stage. So, use\xa0",(0,i.jsx)(n.code,{children:"get_lights"}),"\xa0or\xa0",(0,i.jsx)(n.code,{children:"get_voxels"}),"\xa0to get its individual chunk data."]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"use voxelize::{Space, SpaceData};\n\nimpl ChunkStage for MyStage {\n    /// The radius neighbor from the center chunk that are required before\n    /// being processed in this chunk. Defaults to 0 blocks.\n    fn neighbors(&self, _: &WorldConfig) -> usize {\n        3 // For any reason, you need 3 blocks wider than the chunk size.\n    }\n\n    // Tell the pipeline that you need a space containing a margin of 2 blocks of light data.\n    fn needs_space() -> Option<SpaceData> {\n        // highlight-next-line\n        Some(SpaceData { needs_lights: true, ..Default::default() })    \n    }\n\n    fn process(&self, chunk: Chunk, resources: ResourceResults, space: Option<Space>) -> Chunk {\n        // You can then access neighboring chunk data.\n        // highlight-start\n        let space = space.unwrap();\n        space.get_sunlight(...)\n        // highlight-end\n    }\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:'As can be seen above, the space generated with be expanded by 1 chunk, each chunk requires "3 blocks into the neighboring chunks."'}),"\n",(0,i.jsx)(n.admonition,{type:"info",children:(0,i.jsx)(n.p,{children:"Do note that since using spaces requires extra chunk information other than the center chunk, this would slow generation down as this stage would require neighboring chunks to be processed as well to continue."})}),"\n",(0,i.jsx)(n.h2,{id:"progress-check",children:"Progress Check"}),"\n",(0,i.jsx)(n.p,{children:"The code so far should look like this:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",metastring:'title="server/main.rs"',children:'use voxelize::{Block, FlatlandStage, Registry, Server, Voxelize, World, WorldConfig};\n\n#[actix_web::main]\nasync fn main() -> std::io::Result<()> {\n    let dirt = Block::new("Dirt").id(1).build();\n    let stone = Block::new("Stone").id(2).build();\n    let grass_block = Block::new("Grass Block").id(3).build();\n\n    let config = WorldConfig::new()\n        .min_chunk([-1, -1])\n        .max_chunk([1, 1])\n        .build();\n\n    let mut world = World::new("tutorial", &config);\n\n    {\n        let mut pipeline = world.pipeline_mut();\n        pipeline.add_stage(\n            FlatlandStage::new()\n                .add_soiling(stone.id, 10)\n                .add_soiling(dirt.id, 2)\n                .add_soiling(grass_block.id, 1),\n        )\n    }\n\n    let mut registry = Registry::new();\n    registry.register_blocks(&[dirt, stone, grass_block]);\n\n    let mut server = Server::new().port(4000).registry(&registry).build();\n\n    server\n        .add_world(world)\n        .expect("Failed to add world to server");\n\n    Voxelize::run(server).await\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"Now that we have a server, a world, and all the blocks we needed, let's build the client."})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},9335:(e,n,t)=>{t.d(n,{A:()=>s});const s=t.p+"assets/images/beautiful-mountains-de99a45db7416d9e74fcb8d1dbf3c0b9.png"}}]);