"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[9690],{3023:(e,t,n)=>{n.d(t,{R:()=>r,x:()=>s});var o=n(3696);const a={},d=o.createContext(a);function r(e){const t=o.useContext(d);return o.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function s(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),o.createElement(d.Provider,{value:t},e.children)}},4939:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>i,contentTitle:()=>s,default:()=>h,frontMatter:()=>r,metadata:()=>o,toc:()=>l});const o=JSON.parse('{"id":"calling-methods","title":"Calling Methods","description":"In Voxelize, you can define custom methods that can be called from the client. These methods perform actions on specific worlds, and can be used to create custom game logic.","source":"@site/docs/wiki/calling-methods.md","sourceDirName":".","slug":"/calling-methods","permalink":"/wiki/calling-methods","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","next":{"title":"Chunk Meshing","permalink":"/wiki/chunk-meshing"}}');var a=n(2540),d=n(3023);const r={},s="Calling Methods",i={},l=[{value:"Defining a Server Method",id:"defining-a-server-method",level:2},{value:"Calling a Server Method",id:"calling-a-server-method",level:2},{value:"Difference between Methods and Events",id:"difference-between-methods-and-events",level:2}];function c(e){const t={code:"code",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",...(0,d.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.header,{children:(0,a.jsx)(t.h1,{id:"calling-methods",children:"Calling Methods"})}),"\n",(0,a.jsx)(t.p,{children:"In Voxelize, you can define custom methods that can be called from the client. These methods perform actions on specific worlds, and can be used to create custom game logic."}),"\n",(0,a.jsx)(t.p,{children:"Unlike events, method runs world-wide and is not related to location."}),"\n",(0,a.jsx)(t.h2,{id:"defining-a-server-method",children:"Defining a Server Method"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-rust",metastring:'title="Server Method Definition"',children:'// The payload is a JSON object\n#[derive(Serialize, Deserialize)]\nstruct MyMethodPayload {\n  test: String,\n}\n\nlet world = server.create_world("my_world", &config).expect("Failed to create world");\n\nworld.set_method_handle("my_method", |world, client_id, payload| {\n  let data: MyMethodPayload = serde_json::from_value(payload).expect("Failed to parse payload");\n\n  // Do something with the world and payload\n});\n'})}),"\n",(0,a.jsx)(t.h2,{id:"calling-a-server-method",children:"Calling a Server Method"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-ts",metastring:'title="Client Method Call"',children:'const method = new VOXELIZE.Method();\n\nnetwork.register(method);\n\nmethod.call("my_method", {\n  test: "Hello World"\n})\n'})}),"\n",(0,a.jsx)(t.h2,{id:"difference-between-methods-and-events",children:"Difference between Methods and Events"}),"\n",(0,a.jsx)(t.p,{children:"Methods are intended to be used for actions that change the state of the world. For example, a method could be used to print a message to the console, or to spawn a new entity."}),"\n",(0,a.jsx)(t.p,{children:"On the other hand, events are intended to be reactive. For example, an event could be used to notify the client that a new entity has been spawned, or that a player has been hit."})]})}function h(e={}){const{wrapper:t}={...(0,d.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(c,{...e})}):c(e)}}}]);