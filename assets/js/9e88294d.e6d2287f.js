"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[4130],{40863:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>r,default:()=>h,frontMatter:()=>a,metadata:()=>t,toc:()=>o});const t=JSON.parse('{"id":"blocks/block-registry","title":"Block Registry","description":"The block registry defines all block types on the server\u2014their physical properties, face geometry, transparency, and special behaviors like block entities and dynamic connections.","source":"@site/docs/wiki/blocks/block-registry.md","sourceDirName":"blocks","slug":"/blocks/block-registry","permalink":"/wiki/blocks/block-registry","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1},"sidebar":"tutorialSidebar","previous":{"title":"Blocks","permalink":"/wiki/category/blocks"},"next":{"title":"Block Textures","permalink":"/wiki/blocks/block-textures"}}');var l=s(62540),i=s(43023);const a={sidebar_position:1},r="Block Registry",c={},o=[{value:"Registering Blocks",id:"registering-blocks",level:2},{value:"Block Properties",id:"block-properties",level:2},{value:"Transparency",id:"transparency",level:2},{value:"Face Geometry",id:"face-geometry",level:2},{value:"Compound Blocks",id:"compound-blocks",level:3},{value:"Custom Collision (AABBs)",id:"custom-collision-aabbs",level:2},{value:"Face Texture Types",id:"face-texture-types",level:2},{value:"Standard Faces (Default)",id:"standard-faces-default",level:3},{value:"Independent Faces",id:"independent-faces",level:3},{value:"Isolated Faces",id:"isolated-faces",level:3},{value:"Example: Picture Frame with Isolated Inner Face",id:"example-picture-frame-with-isolated-inner-face",level:3},{value:"Block Entities",id:"block-entities",level:2},{value:"Dynamic Blocks (Conditional Geometry)",id:"dynamic-blocks-conditional-geometry",level:2},{value:"How It Works",id:"how-it-works",level:3},{value:"Block Rules",id:"block-rules",level:3},{value:"Example: Fence Connecting to Any Solid Block",id:"example-fence-connecting-to-any-solid-block",level:3},{value:"Complete Example",id:"complete-example",level:2},{value:"Related Pages",id:"related-pages",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsx)(n.header,{children:(0,l.jsx)(n.h1,{id:"block-registry",children:"Block Registry"})}),"\n",(0,l.jsx)(n.p,{children:"The block registry defines all block types on the server\u2014their physical properties, face geometry, transparency, and special behaviors like block entities and dynamic connections."}),"\n",(0,l.jsx)(n.h2,{id:"registering-blocks",children:"Registering Blocks"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-rust",metastring:'title="Basic Registration"',children:'use voxelize::*;\n\nlet mut registry = Registry::new();\n\nregistry.register_block(&Block::new("Dirt").id(1).build());\nregistry.register_block(&Block::new("Stone").id(2).build());\nregistry.register_block(&Block::new("Glass").id(3).is_transparent(true).is_see_through(true).build());\n\nregistry.generate(); // Compute UV coordinates for texture atlas\n'})}),"\n",(0,l.jsx)(n.h2,{id:"block-properties",children:"Block Properties"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-rust",metastring:'title="Property Examples"',children:'let block = Block::new("Custom Block")\n    .id(100)\n    // Physics\n    .is_solid(true)           // Has collision (default: true)\n    .is_passable(false)       // Entities can walk through (default: false)\n    .is_fluid(false)          // Water-like behavior (default: false)\n    // Light emission\n    .is_light(true)\n    .light_level(14)          // Sets RGB to same value (0-15)\n    // Or per-channel:\n    .red_light_level(15)\n    .green_light_level(12)\n    .blue_light_level(8)\n    // Rotation\n    .rotatable(true)          // Can face any direction\n    .y_rotatable(true)        // Only rotates around Y axis\n    .y_rotatable_segments(YRotatableSegments::Four)  // 90\xb0 increments\n    .build();\n'})}),"\n",(0,l.jsx)(n.h2,{id:"transparency",children:"Transparency"}),"\n",(0,l.jsx)(n.p,{children:"Four properties control transparency behavior:"}),"\n",(0,l.jsxs)(n.table,{children:[(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"Property"}),(0,l.jsx)(n.th,{children:"Effect"})]})}),(0,l.jsxs)(n.tbody,{children:[(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:(0,l.jsx)(n.code,{children:"is_transparent"})}),(0,l.jsx)(n.td,{children:"Adjacent block faces render (face culling)"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:(0,l.jsx)(n.code,{children:"is_see_through"})}),(0,l.jsx)(n.td,{children:"Visual alpha blending on client"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:(0,l.jsx)(n.code,{children:"transparent_standalone"})}),(0,l.jsx)(n.td,{children:"Renders faces between same block type"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:(0,l.jsx)(n.code,{children:"light_reduce"})}),(0,l.jsx)(n.td,{children:"Light decreases by 1 passing through"})]})]})]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-rust",metastring:'title="Transparency Examples"',children:'// Glass: see-through, adjacent faces render\nlet glass = Block::new("Glass")\n    .id(10)\n    .is_transparent(true)\n    .is_see_through(true)\n    .build();\n\n// Water: see-through, dims light, fluid physics\nlet water = Block::new("Water")\n    .id(11)\n    .is_transparent(true)\n    .is_see_through(true)\n    .is_fluid(true)\n    .is_passable(true)\n    .light_reduce(true)\n    .build();\n\n// Leaves: renders faces between adjacent leaves (not a solid mass)\nlet leaves = Block::new("Oak Leaves")\n    .id(12)\n    .is_transparent(true)\n    .is_see_through(true)\n    .light_reduce(true)\n    .transparent_standalone(true)\n    .build();\n\n// Slab: only sides are transparent (top/bottom solid)\nlet slab = Block::new("Stone Slab")\n    .id(13)\n    .is_transparent(true)\n    .is_py_transparent(false)\n    .is_ny_transparent(false)\n    .build();\n'})}),"\n",(0,l.jsx)(n.h2,{id:"face-geometry",children:"Face Geometry"}),"\n",(0,l.jsxs)(n.p,{children:["Customize block shape with scaling, offsets, and prefixes. Default is a standard cube with faces ",(0,l.jsx)(n.code,{children:"px"}),", ",(0,l.jsx)(n.code,{children:"nx"}),", ",(0,l.jsx)(n.code,{children:"py"}),", ",(0,l.jsx)(n.code,{children:"ny"}),", ",(0,l.jsx)(n.code,{children:"pz"}),", ",(0,l.jsx)(n.code,{children:"nz"}),"."]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-rust",metastring:'title="Face Geometry Examples"',children:'// Half-height slab\nlet slab = Block::new("Stone Slab")\n    .id(20)\n    .faces(&BlockFaces::six_faces().scale_y(0.5).build())\n    .build();\n\n// Diagonal X-pattern for plants (faces: "one", "two")\nlet grass = Block::new("Tall Grass")\n    .id(21)\n    .faces(&BlockFaces::diagonal_faces().build())\n    .is_transparent(true)\n    .is_see_through(true)\n    .is_passable(true)\n    .build();\n\n// Torch: thin vertical shape\nlet torch = Block::new("Torch")\n    .id(22)\n    .faces(&BlockFaces::six_faces()\n        .scale_x(0.1)\n        .scale_z(0.1)\n        .scale_y(0.6)\n        .offset_x(0.45)\n        .offset_z(0.45)\n        .build())\n    .is_transparent(true)\n    .is_light(true)\n    .light_level(14)\n    .build();\n'})}),"\n",(0,l.jsx)(n.h3,{id:"compound-blocks",children:"Compound Blocks"}),"\n",(0,l.jsx)(n.p,{children:"Use prefixes to create multi-part blocks where each part can be textured separately on the client:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-rust",metastring:'title="Mushroom with Stem and Cap"',children:'let stem = BlockFaces::six_faces()\n    .prefix("stem").concat("-")\n    .scale_x(0.25).scale_z(0.25)\n    .offset_x(0.375).offset_z(0.375)\n    .build();\n\nlet cap = BlockFaces::six_faces()\n    .prefix("cap").concat("-")\n    .scale_y(0.3).offset_y(0.7)\n    .build();\n\nlet mushroom = Block::new("Mushroom")\n    .id(30)\n    .faces(&(stem + cap))  // Faces: stem-px, stem-ny, cap-py, etc.\n    .is_transparent(true)\n    .build();\n'})}),"\n",(0,l.jsx)(n.h2,{id:"custom-collision-aabbs",children:"Custom Collision (AABBs)"}),"\n",(0,l.jsx)(n.p,{children:"Define collision boxes independent of visual geometry:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-rust",metastring:'title="Custom Collision Examples"',children:'// Fence post: narrow center collision\nlet fence = Block::new("Fence Post")\n    .id(40)\n    .aabbs(&[\n        AABB::new()\n            .scale_x(0.25).scale_z(0.25)\n            .offset_x(0.375).offset_z(0.375)\n            .build()\n    ])\n    .is_transparent(true)\n    .build();\n\n// Table: tabletop + 4 legs\nlet table = Block::new("Table")\n    .id(41)\n    .aabbs(&[\n        AABB::new().scale_y(0.1).offset_y(0.9).build(),\n        AABB::new().scale_x(0.1).scale_z(0.1).scale_y(0.9).build(),\n        AABB::new().scale_x(0.1).scale_z(0.1).scale_y(0.9).offset_x(0.9).build(),\n        AABB::new().scale_x(0.1).scale_z(0.1).scale_y(0.9).offset_z(0.9).build(),\n        AABB::new().scale_x(0.1).scale_z(0.1).scale_y(0.9).offset_x(0.9).offset_z(0.9).build(),\n    ])\n    .build();\n'})}),"\n",(0,l.jsx)(n.h2,{id:"face-texture-types",children:"Face Texture Types"}),"\n",(0,l.jsx)(n.p,{children:"Voxelize supports three texture allocation strategies per face:"}),"\n",(0,l.jsxs)(n.table,{children:[(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"Type"}),(0,l.jsx)(n.th,{children:"Atlas Slot"}),(0,l.jsx)(n.th,{children:"Use Case"}),(0,l.jsx)(n.th,{children:"Client API"})]})}),(0,l.jsxs)(n.tbody,{children:[(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:(0,l.jsx)(n.strong,{children:"Standard"})}),(0,l.jsx)(n.td,{children:"Shared in atlas"}),(0,l.jsx)(n.td,{children:"Normal blocks"}),(0,l.jsx)(n.td,{children:(0,l.jsx)(n.code,{children:"applyBlockTexture"})})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:(0,l.jsx)(n.strong,{children:"Independent"})}),(0,l.jsx)(n.td,{children:"Dedicated, shared"}),(0,l.jsx)(n.td,{children:"High-res textures, animations"}),(0,l.jsx)(n.td,{children:(0,l.jsx)(n.code,{children:"applyBlockTexture"})})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:(0,l.jsx)(n.strong,{children:"Isolated"})}),(0,l.jsx)(n.td,{children:"Dedicated, per-block"}),(0,l.jsx)(n.td,{children:"Per-instance content (signs, pictures)"}),(0,l.jsx)(n.td,{children:(0,l.jsx)(n.code,{children:"applyBlockTextureAt"})})]})]})]}),"\n",(0,l.jsx)(n.h3,{id:"standard-faces-default",children:"Standard Faces (Default)"}),"\n",(0,l.jsx)(n.p,{children:"All block instances share the same texture slot in the atlas. This is memory-efficient for blocks where every instance looks identical."}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-rust",metastring:'title="Standard Faces"',children:'let stone = Block::new("Stone")\n    .id(1)\n    .faces(&BlockFaces::six_faces().build())\n    .build();\n'})}),"\n",(0,l.jsxs)(n.p,{children:["On the client, use ",(0,l.jsx)(n.code,{children:"applyBlockTexture"}),":"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-ts",children:'world.applyBlockTexture("Stone", "*", "/textures/stone.png");\n'})}),"\n",(0,l.jsx)(n.h3,{id:"independent-faces",children:"Independent Faces"}),"\n",(0,l.jsx)(n.p,{children:"A face marked independent gets its own dedicated texture outside the atlas, but still shares that texture across all instances. Use this for high-resolution textures or animated faces that would otherwise consume too much atlas space."}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-rust",metastring:'title="Independent Face"',children:'let monitor = Block::new("Monitor")\n    .id(50)\n    .faces(&BlockFaces::six_faces()\n        .independent_at(SIX_FACES_PZ)  // PZ face gets dedicated texture\n        .build())\n    .build();\n'})}),"\n",(0,l.jsxs)(n.p,{children:["On the client, still use ",(0,l.jsx)(n.code,{children:"applyBlockTexture"}),"\u2014every monitor shows the same screen:"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-ts",children:'world.applyBlockTexture("Monitor", "pz", highResTexture);\n'})}),"\n",(0,l.jsx)(n.h3,{id:"isolated-faces",children:"Isolated Faces"}),"\n",(0,l.jsxs)(n.p,{children:["A face marked isolated gets a unique texture ",(0,l.jsx)(n.strong,{children:"per block instance"}),". This is essential for blocks where each placed instance shows different content\u2014signs with custom text, picture frames with different images, screens with unique displays."]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Requirements:"})}),"\n",(0,l.jsxs)(n.ol,{children:["\n",(0,l.jsxs)(n.li,{children:["Mark faces with ",(0,l.jsx)(n.code,{children:".isolated_at()"})," on the server"]}),"\n",(0,l.jsxs)(n.li,{children:["Set ",(0,l.jsx)(n.code,{children:".is_entity(true)"})," so each instance stores metadata"]}),"\n",(0,l.jsxs)(n.li,{children:["Use ",(0,l.jsx)(n.code,{children:"applyBlockTextureAt"})," on the client (not ",(0,l.jsx)(n.code,{children:"applyBlockTexture"}),")"]}),"\n"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-rust",metastring:'title="Isolated Face with Block Entity"',children:'let sign = Block::new("Oak Wall Sign")\n    .id(23001)\n    .faces(&BlockFaces::six_faces()\n        .scale_z(0.1)\n        .isolated_at(SIX_FACES_PZ)  // Each sign\'s PZ face is unique\n        .build())\n    .is_entity(true)  // Required: enables per-instance data\n    .is_transparent(true)\n    .y_rotatable(true)\n    .build();\n'})}),"\n",(0,l.jsx)(n.p,{children:"On the client, target a specific voxel position:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-ts",children:'world.applyBlockTextureAt(\n  "Oak Wall Sign",\n  "pz",\n  canvasTexture,\n  [10, 5, 20] // This specific sign at this position\n);\n'})}),"\n",(0,l.jsxs)(n.p,{children:["Calling ",(0,l.jsx)(n.code,{children:"applyBlockTexture"})," on an isolated face will silently skip it\u2014isolated faces can only be textured per-instance."]}),"\n",(0,l.jsx)(n.h3,{id:"example-picture-frame-with-isolated-inner-face",children:"Example: Picture Frame with Isolated Inner Face"}),"\n",(0,l.jsx)(n.p,{children:"A picture frame has a wooden border (standard faces) and an inner display area (isolated face):"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-rust",metastring:'title="Picture Frame Registration"',children:'fn create_frame(name: &str, id: u32, dimensions: (f32, f32)) -> Block {\n    let (width, height) = dimensions;\n    let frame_depth = 0.08;\n    let frame_thickness = 0.08;\n    let inner_depth = 0.04;\n\n    // Inner display area - isolated so each frame shows different content\n    let inner_faces = BlockFaces::six_faces()\n        .scale_z(inner_depth)\n        .scale_x(width - frame_thickness * 2.0)\n        .scale_y(height - frame_thickness * 2.0)\n        .offset_x(-(width - 1.0) / 2.0 + frame_thickness)\n        .offset_y(frame_thickness)\n        .isolated_at(SIX_FACES_PZ)  // Each frame\'s display is unique\n        .prefix("inner")\n        .build();\n\n    // Wooden frame border - standard faces, all frames share same texture\n    let top_frame = BlockFaces::six_faces()\n        .scale_z(frame_depth)\n        .scale_x(width)\n        .scale_y(frame_thickness)\n        .offset_x(-(width - 1.0) / 2.0)\n        .offset_y(height - frame_thickness)\n        .prefix("frame")\n        .build();\n\n    // ... bottom, left, right frame pieces ...\n\n    Block::new(name)\n        .id(id)\n        .faces(&(inner_faces + top_frame /* + other frame pieces */))\n        .is_entity(true)  // Required for isolated faces\n        .is_transparent(true)\n        .y_rotatable(true)\n        .build()\n}\n\nregistry.register_block(&create_frame("Picture Frame 1x1", 23060, (1.0, 1.0)));\n'})}),"\n",(0,l.jsx)(n.p,{children:"On the client:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-ts",children:'// All picture frames share the same wooden border texture\nworld.applyBlockTexture(\n  "Picture Frame 1x1",\n  "frame*",\n  "/textures/oak_planks.png"\n);\n\n// Each frame\'s inner display is set individually\nworld.applyBlockTextureAt(\n  "Picture Frame 1x1",\n  "innerpz",\n  userUploadedImage,\n  [10, 5, 20]\n);\n'})}),"\n",(0,l.jsxs)(n.p,{children:["Face constants: ",(0,l.jsx)(n.code,{children:"SIX_FACES_PX"}),", ",(0,l.jsx)(n.code,{children:"SIX_FACES_NX"}),", ",(0,l.jsx)(n.code,{children:"SIX_FACES_PY"}),", ",(0,l.jsx)(n.code,{children:"SIX_FACES_NY"}),", ",(0,l.jsx)(n.code,{children:"SIX_FACES_PZ"}),", ",(0,l.jsx)(n.code,{children:"SIX_FACES_NZ"}),"."]}),"\n",(0,l.jsx)(n.h2,{id:"block-entities",children:"Block Entities"}),"\n",(0,l.jsxs)(n.p,{children:["Blocks with ",(0,l.jsx)(n.code,{children:"is_entity(true)"})," create an entity when placed, storing arbitrary JSON metadata per instance. The client receives updates via ",(0,l.jsx)(n.code,{children:"addBlockEntityUpdateListener"})," and can render accordingly."]}),"\n",(0,l.jsx)(n.p,{children:"Block entities are required for isolated faces because the system needs to track each instance. They're also useful for storing custom data even without isolated faces (e.g., chest contents, redstone state)."}),"\n",(0,l.jsxs)(n.p,{children:["See ",(0,l.jsx)(n.a,{href:"/wiki/blocks/block-textures#per-instance-textures-isolated-faces",children:"Block Textures"})," for the client-side implementation."]}),"\n",(0,l.jsx)(n.h2,{id:"dynamic-blocks-conditional-geometry",children:"Dynamic Blocks (Conditional Geometry)"}),"\n",(0,l.jsx)(n.p,{children:"Dynamic blocks change their geometry based on neighboring blocks\u2014useful for fences, walls, pipes, and connectors."}),"\n",(0,l.jsx)(n.h3,{id:"how-it-works",children:"How It Works"}),"\n",(0,l.jsxs)(n.ol,{children:["\n",(0,l.jsx)(n.li,{children:"Define base geometry (always rendered)"}),"\n",(0,l.jsx)(n.li,{children:"Define conditional parts with rules"}),"\n",(0,l.jsx)(n.li,{children:"When a rule matches, its faces and AABBs are added to the block"}),"\n"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-rust",metastring:'title="Fence with Conditional Connections"',children:'let fence_id = 50000;\n\n// Base post - always visible\nlet post = BlockFaces::six_faces()\n    .scale_x(0.2).scale_z(0.2).scale_y(0.6)\n    .offset_x(0.4).offset_z(0.4)\n    .build();\nlet post_aabb = AABB::from_faces(&post);\n\n// Connection arm for +X direction\nlet arm_px_bottom = BlockFaces::six_faces()\n    .scale_x(0.4).scale_y(0.15).scale_z(0.1)\n    .offset_x(0.6).offset_y(0.15).offset_z(0.45)\n    .build();\nlet arm_px_top = BlockFaces::six_faces()\n    .scale_x(0.4).scale_y(0.15).scale_z(0.1)\n    .offset_x(0.6).offset_y(0.35).offset_z(0.45)\n    .build();\nlet arm_px_faces = [arm_px_bottom.to_vec(), arm_px_top.to_vec()].concat();\nlet arm_px_aabb = AABB::from_faces(&arm_px_faces);\n\nlet fence = Block::new("Fence")\n    .id(fence_id)\n    .faces(&post)\n    .aabbs(&[post_aabb])\n    .is_transparent(true)\n    .is_dynamic(true)\n    .dynamic_patterns(&[BlockDynamicPattern {\n        parts: vec![\n            // Base post - rule is None, always added\n            BlockConditionalPart {\n                rule: BlockRule::None,\n                faces: post.to_vec(),\n                aabbs: vec![post_aabb],\n                is_transparent: [true; 6],\n                ..Default::default()\n            },\n            // +X arm - added when neighbor is solid (not air, water, etc.)\n            BlockConditionalPart {\n                rule: BlockRule::Combination {\n                    logic: BlockRuleLogic::And,\n                    rules: vec![\n                        BlockRule::Combination {\n                            logic: BlockRuleLogic::Not,\n                            rules: vec![BlockRule::Simple(BlockSimpleRule {\n                                offset: Vec3(1, 0, 0),\n                                id: Some(0),  // Not air\n                                ..Default::default()\n                            })],\n                        },\n                    ],\n                },\n                faces: arm_px_faces.clone(),\n                aabbs: vec![arm_px_aabb],\n                is_transparent: [true; 6],\n                ..Default::default()\n            },\n            // Add similar parts for -X, +Z, -Z directions...\n        ],\n    }])\n    .build();\n'})}),"\n",(0,l.jsx)(n.h3,{id:"block-rules",children:"Block Rules"}),"\n",(0,l.jsx)(n.p,{children:"Rules determine when conditional geometry appears:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-rust",metastring:'title="Rule Types"',children:"// Always add this part (use for base geometry in dynamic_patterns)\nBlockRule::None\n\n// Match specific block at offset\nBlockRule::Simple(BlockSimpleRule {\n    offset: Vec3(1, 0, 0),  // Check +X neighbor\n    id: Some(70),           // Must be block ID 70\n    rotation: None,         // Any rotation (or Some(BlockRotation::PY(0.0)))\n    stage: None,            // Any stage (or Some(2))\n})\n\n// Combine rules with logic\nBlockRule::Combination {\n    logic: BlockRuleLogic::And,  // All must match\n    rules: vec![/* ... */],\n}\n\nBlockRule::Combination {\n    logic: BlockRuleLogic::Or,   // Any must match\n    rules: vec![/* ... */],\n}\n\nBlockRule::Combination {\n    logic: BlockRuleLogic::Not,  // Inverts the inner rule\n    rules: vec![/* single rule */],\n}\n"})}),"\n",(0,l.jsx)(n.h3,{id:"example-fence-connecting-to-any-solid-block",children:"Example: Fence Connecting to Any Solid Block"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-rust",metastring:'title="Connect to Non-Air Neighbors"',children:"fn get_fence_connection_rule(offset: Vec3<i32>) -> BlockRule {\n    BlockRule::Combination {\n        logic: BlockRuleLogic::And,\n        rules: vec![\n            // Not air\n            BlockRule::Combination {\n                logic: BlockRuleLogic::Not,\n                rules: vec![BlockRule::Simple(BlockSimpleRule {\n                    offset: offset.clone(),\n                    id: Some(0),\n                    ..Default::default()\n                })],\n            },\n            // Not water\n            BlockRule::Combination {\n                logic: BlockRuleLogic::Not,\n                rules: vec![BlockRule::Simple(BlockSimpleRule {\n                    offset: offset.clone(),\n                    id: Some(30000),\n                    ..Default::default()\n                })],\n            },\n        ],\n    }\n}\n\n// Use for each direction\nlet rule_px = get_fence_connection_rule(Vec3(1, 0, 0));\nlet rule_nx = get_fence_connection_rule(Vec3(-1, 0, 0));\nlet rule_pz = get_fence_connection_rule(Vec3(0, 0, 1));\nlet rule_nz = get_fence_connection_rule(Vec3(0, 0, -1));\n"})}),"\n",(0,l.jsx)(n.h2,{id:"complete-example",children:"Complete Example"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-rust",metastring:'title="Full Block Registration"',children:'use voxelize::*;\n\npub fn register_blocks(registry: &mut Registry) {\n    // Basic solid block\n    registry.register_block(&Block::new("Stone").id(1).build());\n\n    // Transparent block\n    registry.register_block(&Block::new("Glass")\n        .id(10)\n        .is_transparent(true)\n        .is_see_through(true)\n        .build());\n\n    // Light-emitting block\n    registry.register_block(&Block::new("Torch")\n        .id(20)\n        .is_light(true)\n        .light_level(14)\n        .is_transparent(true)\n        .is_passable(true)\n        .faces(&BlockFaces::six_faces()\n            .scale_x(0.1).scale_z(0.1).scale_y(0.6)\n            .offset_x(0.45).offset_z(0.45)\n            .build())\n        .build());\n\n    // Block entity with isolated face for per-instance textures\n    registry.register_block(&Block::new("Sign")\n        .id(30)\n        .is_entity(true)\n        .is_transparent(true)\n        .y_rotatable(true)\n        .faces(&BlockFaces::six_faces()\n            .scale_z(0.1)\n            .isolated_at(SIX_FACES_PZ)\n            .build())\n        .build());\n\n    // Plant with diagonal faces\n    registry.register_block(&Block::new("Tall Grass")\n        .id(40)\n        .is_transparent(true)\n        .is_see_through(true)\n        .is_passable(true)\n        .faces(&BlockFaces::diagonal_faces().build())\n        .build());\n\n    registry.generate();\n}\n'})}),"\n",(0,l.jsx)(n.h2,{id:"related-pages",children:"Related Pages"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.a,{href:"/wiki/blocks/block-textures",children:"Block Textures"})," - Client-side texture application"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.a,{href:"/wiki/blocks/chunk-meshing",children:"Chunk Meshing"})," - How blocks become geometry"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.a,{href:"/wiki/blocks/custom-block-rendering",children:"Custom Block Rendering"})," - Block entity patterns"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,l.jsx)(n,{...e,children:(0,l.jsx)(d,{...e})}):d(e)}},43023:(e,n,s)=>{s.d(n,{R:()=>a,x:()=>r});var t=s(63696);const l={},i=t.createContext(l);function a(e){const n=t.useContext(i);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(l):e.components||l:a(e.components),t.createElement(i.Provider,{value:n},e.children)}}}]);