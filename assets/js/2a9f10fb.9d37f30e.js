"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[3286],{43023:(e,n,s)=>{s.d(n,{R:()=>l,x:()=>a});var t=s(63696);const i={},r=t.createContext(i);function l(e){const n=t.useContext(r);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:l(e.components),t.createElement(r.Provider,{value:n},e.children)}},85785:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>o,contentTitle:()=>a,default:()=>u,frontMatter:()=>l,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"basics/chunk-generation","title":"Chunk Generation","description":"Populate empty chunks with terrain using chunk stages. Each chunk goes through all stages in sequence.","source":"@site/docs/tutorials/basics/5-chunk-generation.md","sourceDirName":"basics","slug":"/basics/chunk-generation","permalink":"/tutorials/basics/chunk-generation","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"sidebar_position":5},"sidebar":"tutorialSidebar","previous":{"title":"World Configuration","permalink":"/tutorials/basics/world-configuration"},"next":{"title":"Create the Client","permalink":"/tutorials/basics/create-the-client"}}');var i=s(62540),r=s(43023);const l={sidebar_position:5},a="Chunk Generation",o={},c=[{value:"Using FlatlandStage",id:"using-flatlandstage",level:2},{value:"How Chunk Stages Work",id:"how-chunk-stages-work",level:2},{value:"Custom Stages",id:"custom-stages",level:2},{value:"Using Space for Neighboring Chunks",id:"using-space-for-neighboring-chunks",level:2}];function d(e){const n={admonition:"admonition",code:"code",h1:"h1",h2:"h2",header:"header",img:"img",li:"li",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"chunk-generation",children:"Chunk Generation"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{src:s(89335).A+"",width:"3456",height:"2158"})}),"\n",(0,i.jsx)(n.p,{children:"Populate empty chunks with terrain using chunk stages. Each chunk goes through all stages in sequence."}),"\n",(0,i.jsx)(n.h2,{id:"using-flatlandstage",children:"Using FlatlandStage"}),"\n",(0,i.jsxs)(n.p,{children:["Voxelize includes a built-in ",(0,i.jsx)(n.code,{children:"FlatlandStage"})," for flat terrain. Add it to the world's pipeline:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",metastring:'title="src/main.rs"',children:'use voxelize::{Block, FlatlandStage, Registry, Server, Voxelize, World, WorldConfig};\n\n#[actix_web::main]\nasync fn main() -> std::io::Result<()> {\n    let dirt = Block::new("Dirt").id(1).build();\n    let stone = Block::new("Stone").id(2).build();\n    let grass_block = Block::new("Grass Block").id(3).build();\n\n    let config = WorldConfig::new()\n        .min_chunk([-10, -10])\n        .max_chunk([10, 10])\n        .build();\n\n    let mut world = World::new("tutorial", &config);\n\n    {\n        let mut pipeline = world.pipeline_mut();\n        pipeline.add_stage(\n            FlatlandStage::new()\n                .add_soiling(stone.id, 10)\n                .add_soiling(dirt.id, 2)\n                .add_soiling(grass_block.id, 1),\n        )\n    }\n\n    let mut registry = Registry::new();\n    registry.register_blocks(&[dirt, stone, grass_block]);\n\n    let mut server = Server::new()\n        .port(4000)\n        .registry(&registry)\n        .build();\n\n    server\n        .add_world(world)\n        .expect("Failed to add world to server");\n\n    Voxelize::run(server).await\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"This creates layers from bottom-up:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"10 layers of stone"}),"\n",(0,i.jsx)(n.li,{children:"2 layers of dirt"}),"\n",(0,i.jsx)(n.li,{children:"1 layer of grass block"}),"\n"]}),"\n",(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsxs)(n.p,{children:["The curly braces around ",(0,i.jsx)(n.code,{children:"pipeline_mut()"})," drop the pipeline reference automatically after use."]})}),"\n",(0,i.jsx)(n.h2,{id:"how-chunk-stages-work",children:"How Chunk Stages Work"}),"\n",(0,i.jsxs)(n.p,{children:["Each stage implements the ",(0,i.jsx)(n.code,{children:"ChunkStage"})," trait. The ",(0,i.jsx)(n.code,{children:"process"})," method receives:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"chunk"})," - The chunk to populate"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"resources"})," - Access to registry and world config"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"space"})," - Optional neighboring chunk data"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Stages run in parallel across multiple threads."}),"\n",(0,i.jsx)(n.h2,{id:"custom-stages",children:"Custom Stages"}),"\n",(0,i.jsxs)(n.p,{children:["Here's a simplified version of how ",(0,i.jsx)(n.code,{children:"FlatlandStage"})," works internally:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",metastring:'title="Custom Flatland Stage"',children:'use voxelize::{ChunkStage, Chunk, ResourceResults, Space, VoxelAccess, Vec3};\n\npub struct MyFlatlandStage {\n    height: i32,\n    top: u32,\n    middle: u32,\n    bottom: u32,\n}\n\nimpl ChunkStage for MyFlatlandStage {\n    fn name(&self) -> String {\n        "MyFlatland".to_owned()\n    }\n\n    fn process(&self, mut chunk: Chunk, _: ResourceResults, _: Option<Space>) -> Chunk {\n        let Vec3(min_x, _, min_z) = chunk.min;\n        let Vec3(max_x, _, max_z) = chunk.max;\n\n        for vx in min_x..max_x {\n            for vz in min_z..max_z {\n                for vy in 0..self.height {\n                    if vy == 0 {\n                        chunk.set_voxel(vx, vy, vz, self.bottom);\n                    } else if vy == self.height - 1 {\n                        chunk.set_voxel(vx, vy, vz, self.top);\n                    } else {\n                        chunk.set_voxel(vx, vy, vz, self.middle);\n                    }\n                }\n            }\n        }\n\n        chunk\n    }\n}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"using-space-for-neighboring-chunks",children:"Using Space for Neighboring Chunks"}),"\n",(0,i.jsxs)(n.p,{children:["When a stage needs data from surrounding chunks (for trees, caves, etc), use ",(0,i.jsx)(n.code,{children:"Space"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",metastring:'title="Stage with Neighbors"',children:"impl ChunkStage for MyStage {\n    fn neighbors(&self, _: &WorldConfig) -> usize {\n        3\n    }\n\n    fn needs_space() -> Option<SpaceData> {\n        Some(SpaceData {\n            needs_lights: true,\n            ..Default::default()\n        })\n    }\n\n    fn process(&self, chunk: Chunk, _: ResourceResults, space: Option<Space>) -> Chunk {\n        let space = space.unwrap();\n        space.get_sunlight(...);\n        chunk\n    }\n}\n"})}),"\n",(0,i.jsx)(n.admonition,{type:"info",children:(0,i.jsxs)(n.p,{children:["Using ",(0,i.jsx)(n.code,{children:"Space"})," slows generation since neighboring chunks must be processed first."]})})]})}function u(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},89335:(e,n,s)=>{s.d(n,{A:()=>t});const t=s.p+"assets/images/beautiful-mountains-de99a45db7416d9e74fcb8d1dbf3c0b9.png"}}]);