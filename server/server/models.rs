use std::io::Write;

use actix::Message as ActixMessage;
use log::warn;
use lz4_flex::block::compress_prepend_size;
use lz4_flex::frame::FrameEncoder;
use prost::Message as ProstMesssage;

use crate::libs::Ndarray;

const COMPRESSION_THRESHOLD: usize = 4096;

fn compress_u32_array(data: &[u32]) -> Vec<u8> {
    if data.is_empty() {
        return Vec::new();
    }

    #[cfg(target_endian = "little")]
    {
        let bytes: &[u8] = unsafe {
            std::slice::from_raw_parts(
                data.as_ptr() as *const u8,
                data.len() * std::mem::size_of::<u32>(),
            )
        };
        return compress_prepend_size(bytes);
    }

    #[cfg(not(target_endian = "little"))]
    {
        let mut bytes = Vec::with_capacity(data.len() * std::mem::size_of::<u32>());
        for &value in data {
            bytes.extend_from_slice(&value.to_le_bytes());
        }
        compress_prepend_size(&bytes)
    }
}

fn compress_i32_array(data: &[i32]) -> Vec<u8> {
    if data.is_empty() {
        return Vec::new();
    }

    #[cfg(target_endian = "little")]
    {
        let bytes: &[u8] = unsafe {
            std::slice::from_raw_parts(
                data.as_ptr() as *const u8,
                data.len() * std::mem::size_of::<i32>(),
            )
        };
        return compress_prepend_size(bytes);
    }

    #[cfg(not(target_endian = "little"))]
    {
        let mut bytes = Vec::with_capacity(data.len() * std::mem::size_of::<i32>());
        for &value in data {
            bytes.extend_from_slice(&value.to_le_bytes());
        }
        compress_prepend_size(&bytes)
    }
}

fn compress_f32_array(data: &[f32]) -> Vec<u8> {
    if data.is_empty() {
        return Vec::new();
    }

    #[cfg(target_endian = "little")]
    {
        let bytes: &[u8] = unsafe {
            std::slice::from_raw_parts(
                data.as_ptr() as *const u8,
                data.len() * std::mem::size_of::<f32>(),
            )
        };
        return compress_prepend_size(bytes);
    }

    #[cfg(not(target_endian = "little"))]
    {
        let mut bytes = Vec::with_capacity(data.len() * std::mem::size_of::<f32>());
        for &value in data {
            bytes.extend_from_slice(&value.to_bits().to_le_bytes());
        }
        compress_prepend_size(&bytes)
    }
}

/// Protocol buffers generated by `prost.rs`.
pub mod protocols {
    include!(concat!(env!("OUT_DIR"), "/protocol.rs"));
}

pub use protocols::Message;

pub type MessageType = protocols::message::Type;
pub type EntityOperation = protocols::entity::Operation;

impl ActixMessage for Message {
    type Result = ();
}

impl Message {
    /// Create a new protobuf message with the idiomatic Builder pattern.
    pub fn new(r#type: &MessageType) -> MessageBuilder {
        MessageBuilder {
            r#type: *r#type,
            ..Default::default()
        }
    }
}

/// Encode message into protocol buffers with LZ4 frame compression for large messages.
pub fn encode_message(message: &Message) -> Vec<u8> {
    let mut buf = Vec::with_capacity(message.encoded_len());
    if let Err(error) = message.encode(&mut buf) {
        warn!("Failed to encode protobuf message: {}", error);
        return Vec::new();
    }

    if buf.len() > COMPRESSION_THRESHOLD {
        let mut encoder = FrameEncoder::new(Vec::with_capacity(buf.len()));
        if encoder.write_all(&buf).is_ok() {
            if let Ok(compressed) = encoder.finish() {
                return compressed;
            }
        }
        warn!("Failed to compress protobuf message, sending uncompressed payload");
    }
    buf
}

/// Decode protocol buffers into a message struct.
pub fn decode_message(buf: &[u8]) -> Result<Message, prost::DecodeError> {
    Message::decode(buf)
}

/// Protocol buffer compatible geometry data structure.
#[derive(Debug, Clone, Default)]
pub struct GeometryProtocol {
    pub voxel: u32,
    pub at: Vec<i32>,
    pub face_name: Option<String>,
    pub positions: Vec<f32>,
    pub indices: Vec<i32>,
    pub uvs: Vec<f32>,
    pub lights: Vec<i32>,
}

/// Protocol buffer compatible mesh data structure.
#[derive(Debug, Clone, Default)]
pub struct MeshProtocol {
    pub level: i32,
    pub geometries: Vec<GeometryProtocol>,
}

/// Protocol buffer compatible chunk data structure.
#[derive(Debug, Clone, Default)]
pub struct ChunkProtocol {
    pub x: i32,
    pub z: i32,
    pub id: String,
    pub meshes: Vec<MeshProtocol>,
    pub voxels: Option<Ndarray<u32>>,
    pub lights: Option<Ndarray<u32>>,
}

/// Protocol buffer compatible peer data structure.
#[derive(Debug, Clone, Default)]
pub struct PeerProtocol {
    pub id: String,
    pub username: String,
    pub metadata: String,
}

/// Protobuf buffer compatible update data structure.
#[derive(Debug, Clone, Default)]
pub struct UpdateProtocol {
    pub vx: i32,
    pub vy: i32,
    pub vz: i32,
    pub voxel: u32,
    pub light: u32,
}

/// Protocol buffer compatible entity data structure.
#[derive(Debug, Clone, Default)]
pub struct EntityProtocol {
    pub operation: EntityOperation,
    pub id: String,
    pub r#type: String,
    pub metadata: Option<String>,
}

#[derive(Debug, Clone, Default)]
pub struct ChatMessageProtocol {
    pub r#type: String,
    pub sender: String,
    pub body: String,
    pub metadata: String,
}

#[derive(Debug, Clone, Default)]
pub struct EventProtocol {
    pub name: String,
    pub payload: String,
}

#[derive(Debug, Clone, Default)]
pub struct MethodProtocol {
    pub name: String,
    pub payload: String,
}

fn map_chunk_protocol(chunk: ChunkProtocol) -> protocols::Chunk {
    let mut mapped_meshes = Vec::with_capacity(chunk.meshes.len());
    for mesh in chunk.meshes {
        let mut mapped_geometries = Vec::with_capacity(mesh.geometries.len());
        for geo in mesh.geometries {
            mapped_geometries.push(protocols::Geometry {
                voxel: geo.voxel,
                at: geo.at,
                face_name: geo.face_name,
                indices: compress_i32_array(&geo.indices),
                positions: compress_f32_array(&geo.positions),
                lights: compress_i32_array(&geo.lights),
                uvs: compress_f32_array(&geo.uvs),
            });
        }
        mapped_meshes.push(protocols::Mesh {
            level: mesh.level,
            geometries: mapped_geometries,
        });
    }
    let lights_data = chunk
        .lights
        .as_ref()
        .map_or(&[][..], |lights| lights.data.as_slice());
    let voxels_data = chunk
        .voxels
        .as_ref()
        .map_or(&[][..], |voxels| voxels.data.as_slice());
    protocols::Chunk {
        id: chunk.id,
        meshes: mapped_meshes,
        lights: compress_u32_array(lights_data),
        voxels: compress_u32_array(voxels_data),
        x: chunk.x,
        z: chunk.z,
    }
}

/// Builder for a protocol buffer message.
#[derive(Default)]
pub struct MessageBuilder {
    r#type: MessageType,

    json: Option<String>,
    text: Option<String>,
    world_name: Option<String>,

    chat: Option<ChatMessageProtocol>,
    method: Option<MethodProtocol>,

    peers: Option<Vec<PeerProtocol>>,
    single_entity: Option<EntityProtocol>,
    entities: Option<Vec<EntityProtocol>>,
    single_event: Option<EventProtocol>,
    events: Option<Vec<EventProtocol>>,
    single_chunk: Option<ChunkProtocol>,
    chunks: Option<Vec<ChunkProtocol>>,
    updates: Option<Vec<UpdateProtocol>>,
}

impl MessageBuilder {
    /// Configure the json data of the protocol.
    pub fn json(mut self, json: &str) -> Self {
        if json.is_empty() {
            self.json = None;
        } else {
            self.json = Some(json.to_owned());
        }
        self
    }

    /// Configure owned json data of the protocol.
    pub fn json_owned(mut self, json: String) -> Self {
        if json.is_empty() {
            self.json = None;
        } else {
            self.json = Some(json);
        }
        self
    }

    /// Configure the text data of the protocol.
    pub fn text(mut self, text: &str) -> Self {
        if text.is_empty() {
            self.text = None;
        } else {
            self.text = Some(text.to_owned());
        }
        self
    }

    /// Configure owned text data of the protocol.
    pub fn text_owned(mut self, text: String) -> Self {
        if text.is_empty() {
            self.text = None;
        } else {
            self.text = Some(text);
        }
        self
    }

    /// Configure the world name of the protocol.
    pub fn world_name(mut self, world_name: &str) -> Self {
        if world_name.is_empty() {
            self.world_name = None;
        } else {
            self.world_name = Some(world_name.to_owned());
        }
        self
    }

    /// Configure the peers data of the protocol.
    pub fn peers(mut self, peers: &[PeerProtocol]) -> Self {
        if peers.is_empty() {
            self.peers = None;
        } else {
            self.peers = Some(peers.to_vec());
        }
        self
    }

    /// Configure owned peers data of the protocol.
    pub fn peers_owned(mut self, peers: Vec<PeerProtocol>) -> Self {
        if peers.is_empty() {
            self.peers = None;
        } else {
            self.peers = Some(peers);
        }
        self
    }

    /// Configure the entities data of the protocol.
    pub fn entities(mut self, entities: &[EntityProtocol]) -> Self {
        self.single_entity = None;
        if entities.is_empty() {
            self.entities = None;
        } else {
            self.entities = Some(entities.to_vec());
        }
        self
    }

    pub fn entity_owned(mut self, entity: EntityProtocol) -> Self {
        self.single_entity = Some(entity);
        self.entities = None;
        self
    }

    /// Configure owned entities data of the protocol.
    pub fn entities_owned(mut self, entities: Vec<EntityProtocol>) -> Self {
        self.single_entity = None;
        if entities.is_empty() {
            self.entities = None;
        } else {
            self.entities = Some(entities);
        }
        self
    }

    /// Configure the set of events to send in this message.
    pub fn events(mut self, events: &[EventProtocol]) -> Self {
        self.single_event = None;
        if events.is_empty() {
            self.events = None;
        } else {
            self.events = Some(events.to_vec());
        }
        self
    }

    pub fn event_owned(mut self, event: EventProtocol) -> Self {
        self.single_event = Some(event);
        self.events = None;
        self
    }

    /// Configure owned events data of the protocol.
    pub fn events_owned(mut self, events: Vec<EventProtocol>) -> Self {
        self.single_event = None;
        if events.is_empty() {
            self.events = None;
        } else {
            self.events = Some(events);
        }
        self
    }

    /// Configure the chunks data of the protocol.
    pub fn chunks(mut self, chunks: &[ChunkProtocol]) -> Self {
        self.single_chunk = None;
        if chunks.is_empty() {
            self.chunks = None;
        } else {
            self.chunks = Some(chunks.to_vec());
        }
        self
    }

    pub fn chunk_owned(mut self, chunk: ChunkProtocol) -> Self {
        self.single_chunk = Some(chunk);
        self.chunks = None;
        self
    }

    /// Configure owned chunks data of the protocol.
    pub fn chunks_owned(mut self, chunks: Vec<ChunkProtocol>) -> Self {
        self.single_chunk = None;
        if chunks.is_empty() {
            self.chunks = None;
        } else {
            self.chunks = Some(chunks);
        }
        self
    }

    /// Configure the voxel update data of the protocol.
    pub fn updates(mut self, updates: &[UpdateProtocol]) -> Self {
        if updates.is_empty() {
            self.updates = None;
        } else {
            self.updates = Some(updates.to_vec());
        }
        self
    }

    /// Configure owned voxel update data of the protocol.
    pub fn updates_owned(mut self, updates: Vec<UpdateProtocol>) -> Self {
        if updates.is_empty() {
            self.updates = None;
        } else {
            self.updates = Some(updates);
        }
        self
    }

    /// Configure the method data of the protocol.
    pub fn method(mut self, method: MethodProtocol) -> Self {
        self.method = Some(method);
        self
    }

    /// Configure the chat data of the protocol.
    pub fn chat(mut self, chat: ChatMessageProtocol) -> Self {
        self.chat = Some(chat);
        self
    }

    /// Create a protocol buffer message.
    pub fn build(self) -> Message {
        let mut message = protocols::Message {
            r#type: self.r#type as i32,
            ..Default::default()
        };

        message.json = self.json.unwrap_or_default();
        message.text = self.text.unwrap_or_default();
        message.world_name = self.world_name.unwrap_or_default();

        if let Some(peers) = self.peers {
            let mut mapped = Vec::with_capacity(peers.len());
            for peer in peers {
                mapped.push(protocols::Peer {
                    id: peer.id,
                    username: peer.username,
                    metadata: peer.metadata,
                });
            }
            message.peers = mapped;
        }

        if let Some(entity) = self.single_entity {
            message.entities = vec![protocols::Entity {
                operation: entity.operation as i32,
                id: entity.id,
                r#type: entity.r#type,
                metadata: entity.metadata.unwrap_or_default(),
            }];
        } else if let Some(entities) = self.entities {
            let mut mapped = Vec::with_capacity(entities.len());
            for entity in entities {
                mapped.push(protocols::Entity {
                    operation: entity.operation as i32,
                    id: entity.id,
                    r#type: entity.r#type,
                    metadata: entity.metadata.unwrap_or_default(),
                });
            }
            message.entities = mapped;
        }

        if let Some(event) = self.single_event {
            message.events = vec![protocols::Event {
                name: event.name,
                payload: event.payload,
            }];
        } else if let Some(events) = self.events {
            let mut mapped = Vec::with_capacity(events.len());
            for event in events {
                mapped.push(protocols::Event {
                    name: event.name,
                    // Convert payload from json to struct
                    payload: event.payload,
                });
            }
            message.events = mapped;
        }

        if let Some(chunk) = self.single_chunk {
            message.chunks = vec![map_chunk_protocol(chunk)];
        } else if let Some(chunks) = self.chunks {
            let mut mapped_chunks = Vec::with_capacity(chunks.len());
            for chunk in chunks {
                mapped_chunks.push(map_chunk_protocol(chunk));
            }
            message.chunks = mapped_chunks;
        }

        if let Some(updates) = self.updates {
            let mut mapped = Vec::with_capacity(updates.len());
            for update in updates {
                mapped.push(protocols::Update {
                    vx: update.vx,
                    vy: update.vy,
                    vz: update.vz,
                    light: update.light,
                    voxel: update.voxel,
                });
            }
            message.updates = mapped;
        }

        if let Some(method) = self.method {
            message.method = Some(protocols::Method {
                name: method.name,
                payload: method.payload,
            });
        }

        if let Some(chat) = self.chat {
            message.chat = Some(protocols::ChatMessage {
                body: chat.body,
                sender: chat.sender,
                r#type: chat.r#type,
                metadata: chat.metadata,
            });
        }

        message
    }
}

#[cfg(test)]
mod tests {
    use super::{
        ChunkProtocol, EntityOperation, EntityProtocol, EventProtocol, Message, MessageType,
        PeerProtocol, UpdateProtocol,
    };

    #[test]
    fn owned_collection_setters_skip_empty_vectors() {
        let message = Message::new(&MessageType::Peer)
            .peers_owned(Vec::new())
            .entities_owned(Vec::new())
            .events_owned(Vec::new())
            .chunks_owned(Vec::new())
            .updates_owned(Vec::new())
            .build();

        assert!(message.peers.is_empty());
        assert!(message.entities.is_empty());
        assert!(message.events.is_empty());
        assert!(message.chunks.is_empty());
        assert!(message.updates.is_empty());
    }

    #[test]
    fn owned_collection_setters_keep_non_empty_vectors() {
        let message = Message::new(&MessageType::Entity)
            .peers_owned(vec![PeerProtocol {
                id: "peer-1".to_owned(),
                username: "name".to_owned(),
                metadata: "{}".to_owned(),
            }])
            .entities_owned(vec![EntityProtocol {
                operation: EntityOperation::Update,
                id: "entity-1".to_owned(),
                r#type: "npc".to_owned(),
                metadata: Some("{}".to_owned()),
            }])
            .events_owned(vec![EventProtocol {
                name: "evt".to_owned(),
                payload: "{}".to_owned(),
            }])
            .chunks_owned(vec![ChunkProtocol {
                id: "chunk-0-0".to_owned(),
                ..Default::default()
            }])
            .updates_owned(vec![UpdateProtocol {
                vx: 1,
                vy: 2,
                vz: 3,
                voxel: 4,
                light: 5,
            }])
            .build();

        assert_eq!(message.peers.len(), 1);
        assert_eq!(message.entities.len(), 1);
        assert_eq!(message.events.len(), 1);
        assert_eq!(message.chunks.len(), 1);
        assert_eq!(message.updates.len(), 1);
    }

    #[test]
    fn chunk_owned_sets_single_chunk_payload() {
        let message = Message::new(&MessageType::Load)
            .chunk_owned(ChunkProtocol {
                id: "chunk-0-0".to_owned(),
                ..Default::default()
            })
            .build();

        assert_eq!(message.chunks.len(), 1);
        assert_eq!(message.chunks[0].id, "chunk-0-0");
    }

    #[test]
    fn chunk_owned_overrides_previous_chunk_list() {
        let message = Message::new(&MessageType::Load)
            .chunks_owned(vec![ChunkProtocol {
                id: "chunk-old".to_owned(),
                ..Default::default()
            }])
            .chunk_owned(ChunkProtocol {
                id: "chunk-new".to_owned(),
                ..Default::default()
            })
            .build();

        assert_eq!(message.chunks.len(), 1);
        assert_eq!(message.chunks[0].id, "chunk-new");
    }

    #[test]
    fn event_owned_sets_single_event_payload() {
        let message = Message::new(&MessageType::Event)
            .event_owned(EventProtocol {
                name: "evt".to_owned(),
                payload: "{\"ok\":true}".to_owned(),
            })
            .build();

        assert_eq!(message.events.len(), 1);
        assert_eq!(message.events[0].name, "evt");
        assert_eq!(message.events[0].payload, "{\"ok\":true}");
    }

    #[test]
    fn event_owned_overrides_previous_event_list() {
        let message = Message::new(&MessageType::Event)
            .events_owned(vec![EventProtocol {
                name: "old".to_owned(),
                payload: "{}".to_owned(),
            }])
            .event_owned(EventProtocol {
                name: "new".to_owned(),
                payload: "{}".to_owned(),
            })
            .build();

        assert_eq!(message.events.len(), 1);
        assert_eq!(message.events[0].name, "new");
    }

    #[test]
    fn entity_owned_sets_single_entity_payload() {
        let message = Message::new(&MessageType::Entity)
            .entity_owned(EntityProtocol {
                operation: EntityOperation::Update,
                id: "entity-1".to_owned(),
                r#type: "npc".to_owned(),
                metadata: Some("{\"hp\":10}".to_owned()),
            })
            .build();

        assert_eq!(message.entities.len(), 1);
        assert_eq!(message.entities[0].id, "entity-1");
        assert_eq!(message.entities[0].r#type, "npc");
        assert_eq!(message.entities[0].metadata, "{\"hp\":10}");
    }

    #[test]
    fn entity_owned_overrides_previous_entity_list() {
        let message = Message::new(&MessageType::Entity)
            .entities_owned(vec![EntityProtocol {
                operation: EntityOperation::Update,
                id: "old".to_owned(),
                r#type: "npc".to_owned(),
                metadata: None,
            }])
            .entity_owned(EntityProtocol {
                operation: EntityOperation::Delete,
                id: "new".to_owned(),
                r#type: "npc".to_owned(),
                metadata: None,
            })
            .build();

        assert_eq!(message.entities.len(), 1);
        assert_eq!(message.entities[0].id, "new");
        assert_eq!(
            EntityOperation::try_from(message.entities[0].operation),
            Ok(EntityOperation::Delete)
        );
    }
}
